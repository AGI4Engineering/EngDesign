{'completion_tokens': 2449, 'response': Response_structure(reasoning='Step-by-step approach\n1. Resolve the pathname `name` to its inode number by traversing the directory tree that starts at the root inode (conventionally 1).  Each component is looked up in the `directories` dictionary; absence raises `FileNotFoundError`.  A non-directory in the middle of the path also raises `FileNotFoundError`.\n2. Once the final component is reached, obtain its inode object.  If the inode represents a directory, raise `IsADirectoryError`.\n3. Validate the supplied offset `pos`.  It must be 0 ≤ pos ≤ current size; otherwise raise `ValueError` so no holes are created.\n4. UTF-8 encode the input string `data` to `data_bytes` and compute `new_end = pos + len(data_bytes)`.\n5. Grow the file if `new_end` exceeds the current size:\n   • Determine how many complete data blocks are required: `needed_blocks = ceil(new_end / block_size)`.\n   • While `len(inode.direct_blocks) < needed_blocks`, call `allocate_block()` and append the returned index to `inode.direct_blocks`.\n6. Iterate over the byte-range being written block by block:\n   • For each affected file-relative block number `file_blk_no`, map it to the real (disk) block index via `inode.direct_blocks[file_blk_no]`.\n   • Fetch the current block contents (may be `None` or shorter than `block_size`); convert to a `bytearray` of length `block_size`, padding with zeroes as needed.\n   • Overwrite the appropriate slice `block[offset:offset+chunk]` with the next `chunk` of `data_bytes`.\n   • Store the mutated bytes back into `fs_img.data_blocks[disk_blk_no]`.\n7. Update `inode.size = max(inode.size, new_end)`.\n8. Return the same `FileSystemImage` instance so the caller can inspect the side-effects.\n\nCorner cases handled:\n• Non-existent file → FileNotFoundError.\n• Path resolves to a directory → IsADirectoryError.\n• Writing past EOF without intermediate fill → ValueError (as prescribed).\n• Automatic block allocation when the file grows.\n• Works with any block size defined in the superblock.', config=ConfigFile(write='def write(fs_img: FileSystemImage, name: str, pos: int, data: str) -> FileSystemImage:\n    """Write UTF-8 encoded *data* into file *name* at byte offset *pos*.\n\n    The function mutates *fs_img* in-place and returns it.\n    """\n    # ------------------------------------------------------------\n    # Helper: resolve a pathname (absolute or relative) to inode #\n    # ------------------------------------------------------------\n    def _resolve(path: str) -> int:\n        # Split the path; treat empty path or \'/\' as root (inode 1)\n        if path in (\'\', \'/\', None):\n            return 1  # root inode\n        # Determine start inode (always root for this simplified FS)\n        curr_ino = 1\n        parts = [p for p in path.strip(\'/\') .split(\'/\') if p]\n        for part in parts:\n            curr_inode = fs_img.inodes.get(curr_ino)\n            if curr_inode is None or not curr_inode.is_dir:\n                raise FileNotFoundError(path)\n            # Build a lookup dict for current directory\n            lookup = {e.name: e.inode for e in fs_img.directories.get(curr_ino, [])}\n            if part not in lookup:\n                raise FileNotFoundError(path)\n            curr_ino = lookup[part]\n        return curr_ino\n\n    # ------------------------------------------------------------\n    # 1. Locate target inode\n    # ------------------------------------------------------------\n    tgt_ino = _resolve(name)\n    inode = fs_img.inodes.get(tgt_ino)\n    if inode is None:\n        raise FileNotFoundError(name)\n    if inode.is_dir:\n        raise IsADirectoryError(name)\n\n    # ------------------------------------------------------------\n    # 2. Validate position argument\n    # ------------------------------------------------------------\n    if pos < 0 or pos > inode.size:\n        raise ValueError("pos must be between 0 and current file size inclusive")\n\n    # ------------------------------------------------------------\n    # 3. Prepare data\n    # ------------------------------------------------------------\n    data_bytes = data.encode("utf-8")\n    if not data_bytes:\n        return fs_img  # nothing to write\n\n    block_size = fs_img.superblock.block_size\n    end_pos = pos + len(data_bytes)\n\n    # ------------------------------------------------------------\n    # 4. Allocate additional blocks if the file grows\n    # ------------------------------------------------------------\n    needed_blocks = (end_pos + block_size - 1) // block_size  # ceil division\n    while len(inode.direct_blocks) < needed_blocks:\n        new_blk = fs_img.allocate_block()\n        inode.direct_blocks.append(new_blk)\n\n    # ------------------------------------------------------------\n    # 5. Write loop\n    # ------------------------------------------------------------\n    remaining = len(data_bytes)\n    write_ptr = 0  # index into data_bytes\n    curr_pos = pos\n\n    while remaining > 0:\n        file_blk_no = curr_pos // block_size\n        blk_offset = curr_pos % block_size\n        to_write = min(remaining, block_size - blk_offset)\n\n        disk_blk_idx = inode.direct_blocks[file_blk_no]\n        existing = fs_img.data_blocks[disk_blk_idx] or b\'\'\n        # Ensure full block length using bytearray for mutability\n        buf = bytearray(existing)\n        if len(buf) < block_size:\n            buf.extend(b\'\\x00\' * (block_size - len(buf)))\n\n        buf[blk_offset : blk_offset + to_write] = data_bytes[write_ptr : write_ptr + to_write]\n        fs_img.data_blocks[disk_blk_idx] = bytes(buf)\n\n        # Advance pointers\n        curr_pos += to_write\n        write_ptr += to_write\n        remaining -= to_write\n\n    # ------------------------------------------------------------\n    # 6. Update metadata and return\n    # ------------------------------------------------------------\n    inode.size = max(inode.size, end_pos)\n    return fs_img')), 'passed': False, 'evaluation_result': {'write': 'correctly raised error for non-existent file', 'read': 'Error in read content check '}, 'score': 80}
