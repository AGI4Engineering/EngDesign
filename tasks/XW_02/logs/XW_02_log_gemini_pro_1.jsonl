{'completion_tokens': 3380, 'response': Response_structure(reasoning="The user wants to implement a `write` function for a custom filesystem class structure.\nMy plan to implement this function is as follows:\n1.  **Path Resolution and Initial Checks**:\n    *   Define a helper function, `get_target_inode_num`, nested within `write`, to resolve the input `name` (which can be an absolute or relative path) to an inode number. This helper will assume inode `1` as the root directory. If the path is `/`, it resolves to the root inode. For other paths, it traverses the directory structure starting from the root.\n    *   If any path component is not found or is not a directory (for intermediate parts), `FileNotFoundError` will be raised.\n    *   Once the target inode number is found, retrieve the `Inode` object.\n    *   If the target inode represents a directory, raise `IsADirectoryError`.\n2.  **Position Validation**:\n    *   Check if the `pos` (write offset) is valid. If `pos < 0` or `pos > inode.size` (current file size), raise `ValueError`.\n3.  **Data Encoding**:\n    *   Encode the input `data` string into bytes using UTF-8. Let these be `data_bytes`.\n    *   If `data_bytes` is empty, there's nothing to write, so return the `fs_img` immediately.\n4.  **File Extension and Block Allocation**:\n    *   Calculate the potential new size of the file: `new_total_size = max(inode.size, pos + len(data_bytes))`.\n    *   Determine the total number of blocks required for this `new_total_size` using `block_size = fs_img.superblock.block_size`.\n    *   If more blocks are needed than currently allocated in `inode.direct_blocks`, allocate the required number of new blocks using `fs_img.allocate_block()`. Append the new block indices to `inode.direct_blocks`. If allocation fails (e.g., no free blocks), a `RuntimeError` should be raised.\n5.  **Writing Data to Blocks**:\n    *   Iterate through `data_bytes`, writing chunks to the appropriate data blocks of the file.\n    *   In each iteration:\n        *   Calculate the `current_file_offset = pos + data_bytes_ptr` (where `data_bytes_ptr` is the amount of data already processed).\n        *   Determine which block in the `inode.direct_blocks` list this offset falls into (`target_block_index_in_inode_list`) and the offset within that block (`offset_in_target_block`).\n        *   Get the actual disk block number: `actual_disk_block_num = inode.direct_blocks[target_block_index_in_inode_list]`.\n        *   Retrieve the `current_block_content` from `fs_img.data_blocks[actual_disk_block_num]` (it's `b''` for newly allocated blocks).\n        *   Calculate how many bytes (`bytes_to_write_this_iteration`) can be written into this block from `offset_in_target_block` without exceeding `block_size` or `len(data_bytes) - data_bytes_ptr`.\n        *   Construct the `new_block_data`:\n            *   Take the `prefix` of `current_block_content` before `offset_in_target_block`. If writing starts past current content in the block (a 'hole'), pad with null bytes (`\\0`).\n            *   Append the `actual_chunk_to_write` (the portion of `data_bytes` for this iteration).\n            *   Append the `suffix` of `current_block_content` that comes after the written chunk, if any.\n            *   Ensure `new_block_data` is not longer than `block_size` (though construction should inherently manage this).\n        *   Update `fs_img.data_blocks[actual_disk_block_num]` with `new_block_data`.\n        *   Increment `data_bytes_ptr` by `bytes_to_write_this_iteration`.\n6.  **Update Metadata**:\n    *   Set `inode.size` to `new_total_size`.\n7.  **Return**:\n    *   Return the modified `fs_img` instance.", config=ConfigFile(write='from typing import List, Dict, Optional\n# Assume SuperBlock, Inode, DirEntry, FileSystemImage classes are defined as per the problem description.\n\ndef write(fs_img: \'FileSystemImage\', name: str, pos: int, data: str) -> \'FileSystemImage\':\n    """Write UTF‑8 bytes of `data` into file `name` at offset `pos` and return the updated image."""\n    ROOT_INODE = 1 # Standard assumption for root directory inode\n\n    # Helper function to resolve path to inode number\n    def get_target_inode_num(current_path: str) -> int:\n        path_parts = [part for part in current_path.split(\'/\') if part]\n        \n        # Determine starting inode (root for absolute, or root as cwd for relative)\n        current_dir_ino = ROOT_INODE\n        # No special handling for current_path.startswith(\'/\') here as we always start from ROOT_INODE\n\n        # Handle case for \'/\' itself\n        if not path_parts:\n            if current_path == "/":\n                if ROOT_INODE in fs_img.inodes and fs_img.inodes[ROOT_INODE].is_dir:\n                    return ROOT_INODE\n                else:\n                    raise FileNotFoundError(f"Root directory (inode {ROOT_INODE}) not found or not a directory.")\n            raise FileNotFoundError(f"Invalid path: \'{current_path}\'")\n\n        # Traverse path components\n        target_component_ino = -1 # To store the inode of the final component\n        for i, part_name in enumerate(path_parts):\n            if current_dir_ino not in fs_img.inodes:\n                raise FileNotFoundError(f"Path resolution failed: Inode {current_dir_ino} for \'{\'/\'.join(path_parts[:i])}\' not found.")\n            \n            current_inode_obj = fs_img.inodes[current_dir_ino]\n            if not current_inode_obj.is_dir:\n                raise FileNotFoundError(f"Path component \'{\'/\'.join(path_parts[:i])}\' (inode {current_dir_ino}) is not a directory.")\n\n            if current_dir_ino not in fs_img.directories:\n                 raise FileNotFoundError(f"Directory \'{\'/\'.join(path_parts[:i])}\' (inode {current_dir_ino}) contains no entries.")\n\n            found_in_dir = False\n            for entry in fs_img.directories[current_dir_ino]:\n                if entry.name == part_name:\n                    if i == len(path_parts) - 1: # This is the final component\n                        target_component_ino = entry.inode\n                    else: # This is an intermediate directory\n                        current_dir_ino = entry.inode\n                    found_in_dir = True\n                    break\n            \n            if not found_in_dir:\n                raise FileNotFoundError(f"Component \'{part_name}\' not found in directory \'{\'/\'.join(path_parts[:i]) if i > 0 else \'/\'}\' (inode {current_dir_ino}).")\n        \n        # If loop finished, target_component_ino should hold the inode of the last part\n        if target_component_ino == -1:\n            # This case implies the path itself resolved to the last directory traversed, e.g. /foo/bar where bar is a directory\n            # The loop structure means \'current_dir_ino\' would be \'bar\'s inode, and target_component_ino not set.\n            # This indicates the path IS the directory \'current_dir_ino\'.\n            if current_dir_ino in fs_img.inodes:\n                 return current_dir_ino\n            raise FileNotFoundError(f"Path resolution error for \'{current_path}\', final component could not be determined.")\n\n        if target_component_ino not in fs_img.inodes:\n            raise FileNotFoundError(f"Inode {target_component_ino} for final component of \'{name}\' not found in filesystem metadata.")\n        \n        return target_component_ino\n\n    # 1. Resolve path and get inode for \'name\'.\n    try:\n        file_ino = get_target_inode_num(name)\n    except FileNotFoundError as e:\n        # Re-raise to ensure the message indicates the original file name if preferred, or pass e\n        raise FileNotFoundError(f"File \'{name}\' not found or path is invalid. Original error: {e}")\n\n    inode = fs_img.inodes[file_ino]\n\n    if inode.is_dir:\n        raise IsADirectoryError(f"Cannot write to \'{name}\': it is a directory.")\n\n    # 2. Validate `pos`.\n    if not (0 <= pos <= inode.size):\n        raise ValueError(f"Position \'pos\' ({pos}) is invalid for file \'{name}\' of size {inode.size}.")\n\n    # 3. Encode `data` as UTF-8 bytes.\n    data_bytes = data.encode(\'utf-8\')\n    data_len = len(data_bytes)\n\n    if data_len == 0: # Nothing to write\n        return fs_img\n\n    # 4. Handle file extension and block allocation.\n    block_size = fs_img.superblock.block_size\n    if block_size <= 0:\n        raise ValueError("Block size must be positive.")\n        \n    write_end_offset = pos + data_len # Byte offset AFTER the last byte to be written\n    new_total_size = max(inode.size, write_end_offset)\n    \n    needed_blocks_total = (new_total_size + block_size - 1) // block_size\n    \n    current_blocks_allocated_count = len(inode.direct_blocks)\n\n    if needed_blocks_total > current_blocks_allocated_count:\n        num_new_blocks_to_allocate = needed_blocks_total - current_blocks_allocated_count\n        for _ in range(num_new_blocks_to_allocate):\n            try:\n                new_block_idx = fs_img.allocate_block() # allocate_block() initializes data_blocks[idx] = b\'\'\n                inode.direct_blocks.append(new_block_idx)\n            except RuntimeError as e: # Propagates "No free blocks available"\n                raise RuntimeError(f"Failed to allocate new block for file \'{name}\': {e}")\n\n    # 5. & 6. Compute ranges and overwrite/append bytes in data_blocks.\n    data_bytes_ptr = 0 # Tracks how many bytes from data_bytes have been processed\n    while data_bytes_ptr < data_len:\n        current_file_offset = pos + data_bytes_ptr # Absolute offset in file for current write chunk\n        \n        target_block_index_in_inode_list = current_file_offset // block_size\n        offset_in_target_block = current_file_offset % block_size\n        \n        if target_block_index_in_inode_list >= len(inode.direct_blocks):\n             # This should not be reached if block allocation above was correct\n             raise RuntimeError(f"Internal error: trying to access block {target_block_index_in_inode_list} but only {len(inode.direct_blocks)} allocated.")\n\n        actual_disk_block_num = inode.direct_blocks[target_block_index_in_inode_list]\n        \n        current_block_content = fs_img.data_blocks[actual_disk_block_num]\n        if current_block_content is None: # Should be b\'\' from allocate_block, but defensive\n            current_block_content = b\'\'\n\n        # Determine how much of data_bytes can be written into the current_block_content from offset_in_target_block\n        writable_space_in_block = block_size - offset_in_target_block\n        bytes_to_write_this_iteration = min(data_len - data_bytes_ptr, writable_space_in_block)\n        \n        chunk_for_this_block = data_bytes[data_bytes_ptr : data_bytes_ptr + bytes_to_write_this_iteration]\n\n        # Assemble the new block content\n        prefix = current_block_content[:offset_in_target_block]\n        if len(prefix) < offset_in_target_block: # Writing past current data in block (hole)\n            prefix += b\'\\0\' * (offset_in_target_block - len(prefix))\n        \n        # Suffix is what remains in the original block *after* the part we overwrite/append to\n        # This is only relevant if we are overwriting a portion of existing data within the block\n        # that extends beyond the current chunk being written.\n        suffix_start_original = offset_in_target_block + len(chunk_for_this_block)\n        suffix = b\'\'\n        if suffix_start_original < len(current_block_content):\n            suffix = current_block_content[suffix_start_original:]\n            \n        new_block_data_list = [prefix, chunk_for_this_block, suffix]\n        new_block_data = b\'\'.join(new_block_data_list)\n        \n        # Ensure the block data does not exceed block_size (it shouldn\'t by construction, but as a safeguard)\n        fs_img.data_blocks[actual_disk_block_num] = new_block_data[:block_size]\n        \n        data_bytes_ptr += bytes_to_write_this_iteration\n\n    # 7. Update the inode’s `size`.\n    inode.size = new_total_size\n    \n    # 8. Return the mutated `fs_img`.\n    return fs_img\n')), 'passed': False, 'evaluation_result': {'write': 'correctly raised error for non-existent file', 'read': 'Error in read content check '}, 'score': 80}
