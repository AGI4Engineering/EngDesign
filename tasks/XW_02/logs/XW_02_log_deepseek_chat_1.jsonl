{'completion_tokens': 3327, 'response': Response_structure(reasoning="To implement the `write` function, we need to follow the specified behavior step by step. Here's the detailed reasoning:\n\n1. **Check File Existence and Type**: First, we need to locate the file `name` in the filesystem. This involves traversing the directory structure to find the inode associated with the file. If the file doesn't exist, raise `FileNotFoundError`. If it's a directory, raise `IsADirectoryError`.\n\n2. **Validate Position**: Ensure that the position `pos` is non-negative and not greater than the current file size. If not, raise `ValueError`.\n\n3. **Encode Data**: Convert the input string `data` to UTF-8 encoded bytes.\n\n4. **Handle File Extension**: If writing beyond the current end of the file, we need to allocate new blocks. This involves:\n   - Calculating how many additional blocks are needed.\n   - Using `fs_img.allocate_block()` to allocate these blocks.\n   - Updating the inode's `direct_blocks` list to include the new blocks.\n\n5. **Determine Block and Byte Ranges**: For the given `pos` and length of the data, determine which blocks and byte ranges within those blocks need to be modified.\n\n6. **Write Data to Blocks**: For each affected block:\n   - If the block is not yet allocated, allocate it.\n   - Modify the relevant bytes within the block to include the new data.\n\n7. **Update Inode Size**: The file's size should be updated to the maximum of its old size or `pos + len(data)`.\n\n8. **Return Updated Filesystem**: Finally, return the mutated `fs_img` with updated data blocks and inode metadata.", config=ConfigFile(write='def write(fs_img: FileSystemImage, name: str, pos: int, data: str) -> FileSystemImage:\n    # Step 1: Locate the file inode\n    inode = None\n    for dir_ino, entries in fs_img.directories.items():\n        for entry in entries:\n            if entry.name == name:\n                inode = fs_img.inodes.get(entry.inode)\n                if inode.is_dir:\n                    raise IsADirectoryError(f"\'{name}\' is a directory")\n                break\n    if not inode:\n        raise FileNotFoundError(f"File \'{name}\' not found")\n\n    # Step 2: Validate position\n    if pos < 0 or pos > inode.size:\n        raise ValueError(f"Invalid position {pos} for file of size {inode.size}")\n\n    # Step 3: Encode data\n    data_bytes = data.encode(\'utf-8\')\n    data_len = len(data_bytes)\n\n    # Step 4: Handle file extension if needed\n    required_size = pos + data_len\n    if required_size > inode.size:\n        block_size = fs_img.superblock.block_size\n        current_blocks = len(inode.direct_blocks)\n        required_blocks = (required_size + block_size - 1) // block_size\n        additional_blocks = required_blocks - current_blocks\n\n        for _ in range(additional_blocks):\n            new_block = fs_img.allocate_block()\n            inode.direct_blocks.append(new_block)\n\n    # Step 5 & 6: Write data to blocks\n    block_size = fs_img.superblock.block_size\n    start_block = pos // block_size\n    end_block = (pos + data_len - 1) // block_size\n\n    data_pos = 0\n    for block_idx in range(start_block, end_block + 1):\n        block_num = inode.direct_blocks[block_idx]\n        block_start = block_idx * block_size\n        block_end = block_start + block_size\n\n        write_start = max(pos, block_start)\n        write_end = min(pos + data_len, block_end)\n        write_len = write_end - write_start\n        block_offset = write_start - block_start\n\n        current_data = fs_img.data_blocks[block_num] or b\'\'\n        if len(current_data) < block_size:\n            current_data += b\'\\x00\' * (block_size - len(current_data))\n        \n        new_data = (\n            current_data[:block_offset] +\n            data_bytes[data_pos:data_pos + write_len] +\n            current_data[block_offset + write_len:]\n        )\n        fs_img.data_blocks[block_num] = new_data\n        data_pos += write_len\n\n    # Step 7: Update inode size\n    inode.size = max(inode.size, pos + data_len)\n\n    # Step 8: Return updated filesystem\n    return fs_img')), 'passed': False, 'evaluation_result': {'write': 'correctly raised error for non-existent file', 'read': 'Error in read content check '}, 'score': 20}
