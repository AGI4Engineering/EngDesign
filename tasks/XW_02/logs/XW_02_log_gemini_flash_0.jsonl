{'completion_tokens': 1013, 'response': Response_structure(reasoning="The task is to implement the `write` function for a filesystem image. This function takes a filesystem image, a filename, a position, and data as input. It writes the UTF-8 encoded bytes of the data into the file at the specified position. The implementation should handle file not found errors, invalid positions, extending the file if writing beyond the current end of the file, and updating the inode's size. The goal is to create the `write` implementation based on the task description.", config=ConfigFile(write='```python\ndef write(\n    fs_img: FileSystemImage,\n    name: str,\n    pos: int,\n    data: str\n) -> FileSystemImage:\n    """Write UTFâ€‘8 bytes of `data` into file `name` at offset `pos` and return the updated image."""\n    # Find the inode for the file\n    inode_num = None\n    for dir_ino, entries in fs_img.directories.items():\n        for entry in entries:\n            if entry.name == name:\n                inode_num = entry.inode\n                break\n        if inode_num is not None:\n            break\n    else:\n        # Check root directory\n        if 1 in fs_img.directories:\n            for entry in fs_img.directories[1]:\n                if entry.name == name:\n                    inode_num = entry.inode\n                    break\n\n\n    if inode_num is None:\n        raise FileNotFoundError(f"File \'{name}\' not found")\n\n    inode = fs_img.inodes[inode_num]\n\n    if inode.is_dir:\n        raise IsADirectoryError(f"\'{name}\' is a directory")\n\n    if pos < 0:\n        raise ValueError("Position cannot be negative")\n\n    byte_data = data.encode(\'utf-8\')\n    data_len = len(byte_data)\n\n    if pos > inode.size:\n        raise ValueError("Position exceeds file size")\n\n    # Calculate the number of blocks needed\n    end_pos = pos + data_len\n    needed_blocks = (end_pos + fs_img.superblock.block_size - 1) // fs_img.superblock.block_size\n\n    # Extend the file if necessary\n    while len(inode.direct_blocks) < needed_blocks:\n        try:\n            block_idx = fs_img.allocate_block()\n            inode.direct_blocks.append(block_idx)\n        except RuntimeError:\n            raise RuntimeError("No free blocks available to extend the file.")\n\n    # Write the data to the blocks\n    bytes_written = 0\n    for i in range(len(inode.direct_blocks)):\n        block_idx = inode.direct_blocks[i]\n        block_start = i * fs_img.superblock.block_size\n        block_end = (i + 1) * fs_img.superblock.block_size\n\n        if pos >= block_end:\n            continue\n\n        block_offset = max(0, pos - block_start)\n        bytes_to_write = min(data_len - bytes_written, fs_img.superblock.block_size - block_offset)\n\n        if bytes_to_write <= 0:\n            break\n\n        block_data = fs_img.data_blocks[block_idx]\n        if block_data is None:\n             block_data = b\'\\0\' * fs_img.superblock.block_size # Initialize with null bytes if block is new\n        block_data = bytearray(block_data)\n\n        block_data[block_offset:block_offset + bytes_to_write] = byte_data[bytes_written:bytes_written + bytes_to_write]\n        fs_img.data_blocks[block_idx] = bytes(block_data)\n\n        bytes_written += bytes_to_write\n\n        if bytes_written >= data_len:\n            break\n\n    # Update the inode size\n    inode.size = max(inode.size, pos + data_len)\n\n    return fs_img\n')), 'passed': False, 'evaluation_result': {'read': 'Error in code execution: invalid syntax (<string>, line 1)'}, 'score': 0}
