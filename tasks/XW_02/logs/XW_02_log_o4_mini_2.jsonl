{'completion_tokens': 3560, 'response': Response_structure(reasoning='To implement the `write` operation we need to:\n\n1. **Path resolution**: Split the provided path on `/` and traverse from the root inode (assumed inode 1). For each component look up its directory entry; if missing, raise `FileNotFoundError`.\n\n2. **Type check**: Once we find the target inode, if it’s marked as a directory, raise `IsADirectoryError`.\n\n3. **Bounds checking**: If `pos` is negative or beyond the current file size, raise `ValueError`.\n\n4. **Prepare data**: UTF-8 encode the input string to bytes and compute the end offset.\n\n5. **Block allocation**: Determine how many blocks are needed to cover `[pos, end)` in units of `block_size`. While the inode’s `direct_blocks` list is too short, call `fs_img.allocate_block()` and append new block indices.\n\n6. **Write loop**: For each chunk of data:\n   - Compute the global byte offset, identify which block and in-block offset.\n   - Read the existing block (or treat missing data as zero bytes), pad to `block_size`.\n   - Overwrite the slice of bytes in that block with the new data chunk.\n   - Store the updated block back into `fs_img.data_blocks`.\n\n7. **Update metadata**: Set `inode.size` to the maximum of the old size and the new end offset.\n\n8. **Return** the mutated `fs_img` for inspection.\n\nThis covers all error conditions, correctly allocates and writes to data blocks, and maintains file size.', config=ConfigFile(write='def write(fs_img: FileSystemImage, name: str, pos: int, data: str) -> FileSystemImage:\n    """Write UTF-8 bytes of `data` into file `name` at offset `pos` and return the updated image."""\n    # Resolve the path from root inode (1)\n    parts = [p for p in name.split(\'/\') if p]\n    curr_ino = 1\n    for part in parts:\n        if curr_ino not in fs_img.directories:\n            raise FileNotFoundError(f\'Path not found: {name}\')\n        found = False\n        for entry in fs_img.directories[curr_ino]:\n            if entry.name == part:\n                curr_ino = entry.inode\n                found = True\n                break\n        if not found:\n            raise FileNotFoundError(f\'Path not found: {name}\')\n    inode = fs_img.inodes.get(curr_ino)\n    if inode is None:\n        raise FileNotFoundError(f\'Path not found: {name}\')\n    if inode.is_dir:\n        raise IsADirectoryError(f\'Is a directory: {name}\')\n    # Validate write position\n    if pos < 0 or pos > inode.size:\n        raise ValueError(f\'Invalid position: {pos}\')\n    # Encode data and compute end offset\n    data_bytes = data.encode(\'utf-8\')\n    end_pos = pos + len(data_bytes)\n    block_size = fs_img.superblock.block_size\n    # Allocate new blocks if needed\n    required_blocks = (end_pos + block_size - 1) // block_size\n    while len(inode.direct_blocks) < required_blocks:\n        new_blk = fs_img.allocate_block()\n        inode.direct_blocks.append(new_blk)\n    # Write data chunk by chunk\n    written = 0\n    while written < len(data_bytes):\n        curr_offset = pos + written\n        blk_idx = curr_offset // block_size\n        blk_num = inode.direct_blocks[blk_idx]\n        blk_off = curr_offset % block_size\n        # Determine how many bytes to write into this block\n        space = block_size - blk_off\n        chunk = data_bytes[written:written + space]\n        # Read existing block (or zero-fill)\n        existing = fs_img.data_blocks[blk_num] or b\'\'\n        if len(existing) < block_size:\n            existing = existing.ljust(block_size, b\'\\x00\')\n        # Merge new chunk\n        new_block = existing[:blk_off] + chunk + existing[blk_off + len(chunk):]\n        fs_img.data_blocks[blk_num] = new_block\n        written += len(chunk)\n    # Update the inode size\n    inode.size = max(inode.size, end_pos)\n    return fs_img')), 'passed': False, 'evaluation_result': {'write': 'correctly raised error for non-existent file', 'read': 'Error in read content check '}, 'score': 80}
