{'completion_tokens': 2647, 'response': Response_structure(reasoning='We need to implement the write() filesystem call that mutates the in-memory FileSystemImage.\n\n1.  Path lookup\n    • Treat inode 1 as the root directory.\n    • Split the supplied name on “/”; walk directory entries to find the final inode.\n    • Raise FileNotFoundError if any component is missing; raise IsADirectoryError if the target inode is a directory.\n\n2.  Argument validation\n    • pos must be ≥ 0 and ≤ current file size, otherwise ValueError.\n\n3.  Encode the data string with UTF-8.\n\n4.  Work out how many logical file blocks are touched:  from start-block = pos//block_size to end-block = (pos+len(data_bytes)-1)//block_size.\n    • Ensure inode.direct_blocks has a physical block for every logical block that will be written.  Allocate new blocks with fs_img.allocate_block() when necessary and append the returned index to inode.direct_blocks.\n\n5.  Perform the write\n    • Iterate while any bytes remain to be written.\n    • For each logical block:  fetch the physical block number; load its current contents (or zeros if the block is empty) into a bytearray of exactly block_size bytes.\n    • Overwrite the appropriate slice inside that bytearray, copy the mutated buffer back to fs_img.data_blocks[phys_idx].\n\n6.  Update inode.size = max(old_size, pos+len(data_bytes)).\n\n7.  Return the mutated fs_img so that the caller can inspect inodes and data_blocks.\n\nThe function below follows these steps strictly and remains faithful to the FileSystemImage helper methods provided in the prompt.', config=ConfigFile(write='def write(fs_img: FileSystemImage, name: str, pos: int, data: str) -> FileSystemImage:\n    """Write UTF-8 bytes of `data` into file `name` at byte offset `pos`.\n    The FileSystemImage is mutated in-place and returned.\n    """\n\n    # -------------------------------------------------------------\n    # 1. Resolve path -> inode\n    # -------------------------------------------------------------\n    def _resolve_path(img: FileSystemImage, path: str):\n        """Return (inode_number, inode_obj) for the given path."""\n        if not path:\n            raise FileNotFoundError("Empty path")\n\n        # Start from root inode (conventionally ino == 1)\n        if 1 not in img.inodes or not img.inodes[1].is_dir:\n            raise RuntimeError("Corrupted file-system: missing root directory (inode 1)")\n        curr_ino = 1\n\n        components = [c for c in path.split(\'/\') if c]\n        # If path is just \'/\', we would end up with components == []\n        if not components:\n            raise IsADirectoryError("Path refers to a directory, not a file")\n\n        for comp in components[:-1]:\n            # Walk intermediate directories\n            dir_entries = img.directories.get(curr_ino)\n            if dir_entries is None:\n                raise NotADirectoryError(f"Component \'{comp}\' is not a directory")\n            try:\n                next_ino = next(e.inode for e in dir_entries if e.name == comp)\n            except StopIteration:\n                raise FileNotFoundError(path)\n            next_inode = img.inodes[next_ino]\n            if not next_inode.is_dir:\n                raise NotADirectoryError(f"Component \'{comp}\' is not a directory")\n            curr_ino = next_ino\n\n        # Final component must be a file\n        final_name = components[-1]\n        dir_entries = img.directories.get(curr_ino)\n        if dir_entries is None:\n            raise NotADirectoryError("Parent component is not a directory")\n        try:\n            file_ino = next(e.inode for e in dir_entries if e.name == final_name)\n        except StopIteration:\n            raise FileNotFoundError(path)\n        file_inode = img.inodes[file_ino]\n        if file_inode.is_dir:\n            raise IsADirectoryError(path)\n        return file_ino, file_inode\n\n    # -------------------------------------------------------------\n    # 2. Validation & preparation\n    # -------------------------------------------------------------\n    file_ino, inode = _resolve_path(fs_img, name)\n\n    if pos < 0 or pos > inode.size:\n        raise ValueError("pos must be between 0 and current file size inclusive")\n\n    data_bytes = data.encode("utf-8")\n    if not data_bytes:\n        return fs_img  # nothing to do\n\n    sb = fs_img.superblock\n    block_size = sb.block_size\n\n    start_block = pos // block_size\n    end_block = (pos + len(data_bytes) - 1) // block_size\n\n    # -------------------------------------------------------------\n    # 3. Ensure all required blocks exist, allocate if necessary\n    # -------------------------------------------------------------\n    while len(inode.direct_blocks) <= end_block:\n        phys_idx = fs_img.allocate_block()\n        inode.direct_blocks.append(phys_idx)\n\n    # -------------------------------------------------------------\n    # 4. Actual data write loop\n    # -------------------------------------------------------------\n    remaining = memoryview(data_bytes)  # zero-copy slicing\n    curr_pos = pos\n\n    while remaining:\n        logical_blk = curr_pos // block_size\n        blk_offset = curr_pos % block_size\n        write_len = min(len(remaining), block_size - blk_offset)\n\n        phys_idx = inode.direct_blocks[logical_blk]\n        stored = fs_img.data_blocks[phys_idx] or b""\n\n        # Bring current block into a mutable bytearray of full block_size\n        buf = bytearray(block_size)\n        buf[:len(stored)] = stored\n\n        # Overwrite slice\n        buf[blk_offset:blk_offset + write_len] = remaining[:write_len]\n\n        # Persist back\n        fs_img.data_blocks[phys_idx] = bytes(buf)\n\n        # Advance\n        remaining = remaining[write_len:]\n        curr_pos += write_len\n\n    # -------------------------------------------------------------\n    # 5. Update inode metadata and return\n    # -------------------------------------------------------------\n    inode.size = max(inode.size, pos + len(data_bytes))\n    return fs_img')), 'passed': False, 'evaluation_result': {'write': 'correctly raised error for non-existent file', 'read': 'Error in read content check '}, 'score': 80}
