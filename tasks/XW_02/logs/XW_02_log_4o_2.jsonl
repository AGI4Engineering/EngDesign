{'completion_tokens': 1044, 'response': Response_structure(reasoning="To implement the `write` function, we need to follow a series of steps to ensure that the data is correctly written to the file system image. Here's a detailed breakdown of the process:\n\n1. **Locate the File**: First, we need to locate the file within the file system image using the provided `name`. This involves traversing the directory structure to find the corresponding inode for the file.\n\n2. **Validate the File**: Once the inode is found, we need to ensure that it is not a directory. If it is, we raise an `IsADirectoryError`. If the file does not exist, we raise a `FileNotFoundError`.\n\n3. **Validate the Position**: We check if the provided `pos` is valid. It should not be negative or greater than the current size of the file. If it is, we raise a `ValueError`.\n\n4. **Encode Data**: The `data` string is encoded into UTF-8 bytes, which will be written to the file.\n\n5. **Calculate Write Range**: Determine the range of bytes that need to be written, starting from `pos` and extending to `pos + len(bytes)`.\n\n6. **Allocate Blocks**: If the write operation extends beyond the current end of the file, we need to allocate new blocks using `fs_img.allocate_block()`. These blocks are added to the inode's `direct_blocks` list.\n\n7. **Write Data**: Calculate which blocks and byte ranges within them correspond to the target file range. Overwrite or append bytes in `fs_img.data_blocks[block_idx]` for each block involved.\n\n8. **Update Inode Size**: After writing, update the inode's `size` to be the maximum of the old size and `pos + len(bytes)`.\n\n9. **Return Updated FileSystemImage**: Finally, return the mutated `fs_img` so that the changes can be inspected.\n\nNow, let's implement the `write` function based on this reasoning.", config=ConfigFile(write='def write(fs_img: FileSystemImage, name: str, pos: int, data: str) -> FileSystemImage:\n    # Step 1: Locate the file\n    # Traverse the directory structure to find the inode for the file\n    inode_number = None\n    for dir_inode, entries in fs_img.directories.items():\n        for entry in entries:\n            if entry.name == name:\n                inode_number = entry.inode\n                break\n        if inode_number is not None:\n            break\n\n    # Step 2: Validate the file\n    if inode_number is None:\n        raise FileNotFoundError(f"File \'{name}\' not found.")\n\n    inode = fs_img.inodes[inode_number]\n    if inode.is_dir:\n        raise IsADirectoryError(f"\'{name}\' is a directory.")\n\n    # Step 3: Validate the position\n    if pos < 0 or pos > inode.size:\n        raise ValueError("Position is out of bounds.")\n\n    # Step 4: Encode data\n    data_bytes = data.encode(\'utf-8\')\n\n    # Step 5: Calculate write range\n    end_pos = pos + len(data_bytes)\n\n    # Step 6: Allocate blocks if necessary\n    current_block_count = len(inode.direct_blocks)\n    required_blocks = (end_pos + fs_img.superblock.block_size - 1) // fs_img.superblock.block_size\n\n    while current_block_count < required_blocks:\n        new_block_idx = fs_img.allocate_block()\n        inode.direct_blocks.append(new_block_idx)\n        current_block_count += 1\n\n    # Step 7: Write data\n    block_size = fs_img.superblock.block_size\n    current_pos = pos\n    data_offset = 0\n\n    while data_offset < len(data_bytes):\n        block_idx = current_pos // block_size\n        block_offset = current_pos % block_size\n        block_number = inode.direct_blocks[block_idx]\n\n        # Calculate how much data to write in this block\n        write_length = min(block_size - block_offset, len(data_bytes) - data_offset)\n\n        # Write data to the block\n        block_data = fs_img.data_blocks[block_number] or b\'\'\n        block_data = block_data[:block_offset] + data_bytes[data_offset:data_offset + write_length] + block_data[block_offset + write_length:]\n        fs_img.data_blocks[block_number] = block_data\n\n        # Update positions\n        current_pos += write_length\n        data_offset += write_length\n\n    # Step 8: Update inode size\n    inode.size = max(inode.size, end_pos)\n\n    # Step 9: Return updated FileSystemImage\n    return fs_img')), 'passed': False, 'evaluation_result': {'write': 'correctly raised error for non-existent file', 'read': 'Error in read content check '}, 'score': 20}
