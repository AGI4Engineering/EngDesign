{'completion_tokens': 2187, 'response': Response_structure(reasoning="Below is an implementation of the 'write' function fulfilling the specified requirements, using the provided class definitions and method placeholders. It demonstrates how to locate a file's inode, validate the position, extend blocks if needed, then write the UTF-8-encoded data to the underlying data blocks while updating the inode's size.\n", config=ConfigFile(write='def write(fs_img: FileSystemImage, name: str, pos: int, data: str) -> FileSystemImage:\n    """\n    Write the UTF-8 encoded bytes of `data` into the file called `name`\n    in the given FileSystemImage, starting at byte offset `pos`. Return\n    the updated FileSystemImage so that its blocks and inode metadata\n    can be inspected for correctness.\n\n    Parameters:\n    - fs_img:   the FileSystemImage instance containing inodes, directories,\n                and data blocks.\n    - name:     an absolute or relative path to the target file within `fs_img`.\n    - pos:      the byte offset within the file at which to begin writing.\n    - data:     a Python string whose UTF‑8 encoding will be written.\n\n    Returns:\n    - The same FileSystemImage instance (`fs_img`), mutated to reflect the\n      writes (updated data_blocks and inode.size).\n\n    Behavior:\n    1. If the file `name` does not exist or refers to a directory, raise\n       `FileNotFoundError` or `IsADirectoryError` respectively.\n    2. If `pos` is negative or greater than the file’s current size, raise\n       `ValueError`.\n    3. Encode `data` as UTF-8 bytes.\n    4. If writing beyond the current end of file, extend the file:\n       - Allocate new blocks via `fs_img.allocate_block()` as needed.\n       - Update the inode’s `direct_blocks` list accordingly.\n    5. Compute which blocks and byte‑ranges within them correspond to\n       the target file range `[pos, pos + len(bytes))`.\n    6. Overwrite or append bytes in `fs_img.data_blocks[block_idx]` per block.\n    7. Update the inode’s `size` to `max(old_size, pos + len(bytes))`.\n    8. Return the mutated `fs_img` so that test harnesses can inspect\n       its `data_blocks` and `inodes` for correctness.\n    """\n    # 1. Find the file\'s inode. We assume it\'s in the root directory or a single-level dir.\n    #    For simplicity, we\'ll search all directories for an exact match.\n\n    target_inode = None\n    for dir_ino, entries in fs_img.directories.items():\n        for entry in entries:\n            if entry.name == name:\n                # Found an entry matching \'name\'. Get its inode.\n                inode_obj = fs_img.inodes[entry.inode]\n                if inode_obj.is_dir:\n                    raise IsADirectoryError(f"\'{name}\' is a directory")\n                target_inode = inode_obj\n                break\n        if target_inode:\n            break\n\n    if target_inode is None:\n        raise FileNotFoundError(f"\'{name}\' not found")\n\n    # 2. Validate the \'pos\' range.\n    if pos < 0 or pos > target_inode.size:\n        raise ValueError(f"Invalid write position {pos}, file size is {target_inode.size}")\n\n    # 3. Encode \'data\' as UTF-8.\n    data_bytes = data.encode(\'utf-8\')\n    write_length = len(data_bytes)\n    end_pos = pos + write_length\n\n    # 4. If writing beyond the current end of file, allocate new blocks.\n    block_size = fs_img.superblock.block_size\n    current_blocks = len(target_inode.direct_blocks)\n\n    # Calculate total blocks needed by the time we finish this write.\n    required_blocks_after_write = (end_pos + block_size - 1) // block_size  # integer ceil\n\n    # If we don\'t have enough allocated blocks, allocate more.\n    while len(target_inode.direct_blocks) < required_blocks_after_write:\n        new_block_idx = fs_img.allocate_block()\n        target_inode.direct_blocks.append(new_block_idx)\n\n    # 5. Write data into blocks.\n    # We\'ll iterate from \'pos\' to \'end_pos\' in terms of blocks.\n    bytes_remaining = write_length\n    data_offset = 0  # index in data_bytes\n    current_pos = pos\n\n    while bytes_remaining > 0:\n        block_index_in_file = current_pos // block_size  # which block in the file\n        block_offset = current_pos % block_size         # offset within that block\n\n        block_idx = target_inode.direct_blocks[block_index_in_file]\n        block_data = fs_img.data_blocks[block_idx]\n        if block_data is None:\n            block_data = b\'\'\n\n        # Ensure block_data has the correct length in memory\n        block_data_len = len(block_data)\n        # Expand if needed\n        if block_data_len < block_size:\n            block_data = block_data + b\'\\x00\' * (block_size - block_data_len)\n\n        # Determine how many bytes we can write into this block\n        space_in_block = block_size - block_offset\n        to_write = min(space_in_block, bytes_remaining)\n\n        # Overwrite the relevant part\n        new_block_data = (\n            block_data[:block_offset]\n            + data_bytes[data_offset:data_offset+to_write]\n            + block_data[block_offset + to_write:]\n        )\n\n        fs_img.data_blocks[block_idx] = new_block_data\n\n        # Move to next chunk\n        data_offset += to_write\n        current_pos += to_write\n        bytes_remaining -= to_write\n\n    # 7. Update the inode\'s size.\n    target_inode.size = max(target_inode.size, end_pos)\n\n    # 8. Return fs_img\n    return fs_img\n')), 'passed': False, 'evaluation_result': {'write': 'correctly raised error for non-existent file', 'read': 'Error in read content check '}, 'score': 20}
