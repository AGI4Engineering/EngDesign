{'completion_tokens': 2688, 'response': Response_structure(reasoning="To implement the `write` function, we need to follow the specified behavior step by step. Here's the detailed reasoning:", config=ConfigFile(write='def write(fs_img: FileSystemImage, name: str, pos: int, data: str) -> FileSystemImage:\n    """Write UTFâ€‘8 bytes of `data` into file `name` at offset `pos` and return the updated image."""\n    # Step 1: Locate the file inode\n    inode = None\n    for dir_ino, entries in fs_img.directories.items():\n        for entry in entries:\n            if entry.name == name:\n                inode = fs_img.inodes[entry.inode]\n                break\n        if inode is not None:\n            break\n    if inode is None:\n        raise FileNotFoundError(f"File {name} not found")\n    if inode.is_dir:\n        raise IsADirectoryError(f"{name} is a directory")\n\n    # Step 2: Validate position\n    if pos < 0 or pos > inode.size:\n        raise ValueError(f"Invalid position {pos} for file of size {inode.size}")\n\n    # Step 3: Encode data\n    data_bytes = data.encode(\'utf-8\')\n    data_len = len(data_bytes)\n\n    # Step 4: Handle file extension if needed\n    required_size = pos + data_len\n    if required_size > inode.size:\n        # Calculate how many additional blocks are needed\n        block_size = fs_img.superblock.block_size\n        current_blocks = (inode.size + block_size - 1) // block_size\n        needed_blocks = (required_size + block_size - 1) // block_size - current_blocks\n        for _ in range(needed_blocks):\n            new_block = fs_img.allocate_block()\n            inode.direct_blocks.append(new_block)\n\n    # Step 5 & 6: Determine block ranges and perform write\n    block_size = fs_img.superblock.block_size\n    for i in range(data_len):\n        global_pos = pos + i\n        block_idx = global_pos // block_size\n        block_offset = global_pos % block_size\n        block_num = inode.direct_blocks[block_idx]\n        block_data = bytearray(fs_img.data_blocks[block_num] or b\'\\x00\' * block_size)\n        block_data[block_offset] = data_bytes[i]\n        fs_img.data_blocks[block_num] = bytes(block_data)\n\n    # Step 7: Update inode size\n    inode.size = max(inode.size, required_size)\n\n    # Step 8: Return updated image\n    return fs_img')), 'passed': False, 'evaluation_result': {'write': 'correctly raised error for non-existent file', 'read': 'Error in read content check '}, 'score': 20}
