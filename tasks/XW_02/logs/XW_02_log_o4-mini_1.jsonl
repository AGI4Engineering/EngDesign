{"completion_tokens": 2127, "response": "reasoning='We need to implement the `write` operation for our in-memory filesystem image. The steps are:\\n\\n1. Resolve the file path (`name`) against our directory structure, starting from a root inode (we assume inode 1 is the root directory). If any component is missing, raise `FileNotFoundError`.\\n2. Retrieve the target inode; if it\u2019s a directory, raise `IsADirectoryError`.\\n3. Validate the write position `pos`: it must be between 0 and the current file size inclusive, otherwise raise `ValueError`.\\n4. Encode the input `data` as UTF-8 bytes and calculate the new end offset.\\n5. Determine which blocks cover the range `[pos, pos+len(data_bytes))`. For each block in this range that isn\u2019t already allocated to the file, call `fs_img.allocate_block()` and append its index to `inode.direct_blocks`.\\n6. Write the appropriate slice of our byte string into each block, using a mutable `bytearray` to fill in a partial block, extending it with zeroes if necessary, then store it back as an immutable `bytes` object in `fs_img.data_blocks[block_index]`.\\n7. Update `inode.size` with the new maximum file size.\\n8. Return the mutated `fs_img`.\\n\\nThis approach ensures we correctly handle partial\u2010block writes, dynamic block allocation, and metadata updates.' config=ConfigFile(write='def write(fs_img: FileSystemImage, name: str, pos: int, data: str) -> FileSystemImage:\\n    # Helper: resolve an absolute or relative path to an inode number\\n    def resolve_path(fs_img, path):\\n        parts = [p for p in path.strip(\"/\").split(\"/\") if p]\\n        curr_ino = 1  # assume root directory has inode 1\\n        for p in parts:\\n            if curr_ino not in fs_img.directories:\\n                raise FileNotFoundError(f\"Not a directory: {p}\")\\n            found = False\\n            for entry in fs_img.directories[curr_ino]:\\n                if entry.name == p:\\n                    curr_ino = entry.inode\\n                    found = True\\n                    break\\n            if not found:\\n                raise FileNotFoundError(f\"Path component not found: {p}\")\\n        return curr_ino\\n\\n    # 1. Locate the inode\\n    ino = resolve_path(fs_img, name)\\n    inode = fs_img.inodes.get(ino)\\n    if inode is None:\\n        raise FileNotFoundError(f\"File not found: {name}\")\\n    if inode.is_dir:\\n        raise IsADirectoryError(f\"Is a directory: {name}\")\\n\\n    # 2. Validate position\\n    if pos < 0 or pos > inode.size:\\n        raise ValueError(f\"Invalid write position: {pos}\")\\n\\n    # 3. Prepare data and compute new size\\n    data_bytes = data.encode(\\'utf-8\\')\\n    total_len = len(data_bytes)\\n    end_offset = pos + total_len\\n    bs = fs_img.superblock.block_size\\n\\n    # 4. Ensure enough blocks are allocated\\n    first_blk = pos // bs\\n    last_blk = (end_offset - 1) // bs if total_len > 0 else first_blk\\n    for blk_idx in range(first_blk, last_blk + 1):\\n        if blk_idx >= len(inode.direct_blocks):\\n            new_block = fs_img.allocate_block()\\n            inode.direct_blocks.append(new_block)\\n\\n    # 5. Write data across blocks\\n    offset = pos\\n    remaining = data_bytes\\n    while remaining:\\n        blk_num = offset // bs\\n        block_id = inode.direct_blocks[blk_num]\\n        blk_start = blk_num * bs\\n        start_in_blk = offset - blk_start\\n        space = bs - start_in_blk\\n        chunk = remaining[:space]\\n        # Read existing block data or start fresh\\n        orig = fs_img.data_blocks[block_id] or b\\'\\'\\n        ba = bytearray(orig)\\n        end_in_blk = start_in_blk + len(chunk)\\n        if len(ba) < end_in_blk:\\n            ba.extend(b\\'\\\\x00\\' * (end_in_blk - len(ba)))\\n        ba[start_in_blk:end_in_blk] = chunk\\n        fs_img.data_blocks[block_id] = bytes(ba)\\n        # Advance\\n        written = len(chunk)\\n        offset += written\\n        remaining = remaining[written:]\\n\\n    # 6. Update file size\\n    inode.size = max(inode.size, end_offset)\\n    return fs_img')", "passed": false, "evaluation_result": {"write": "correctly raised error for non-existent file", "read": "Error in read content check "}, "score": 80}
