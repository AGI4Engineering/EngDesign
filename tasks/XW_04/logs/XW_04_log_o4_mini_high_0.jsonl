{'completion_tokens': 3680, 'response': Response_structure(reasoning='To satisfy the requirements, we need four standalone functions—read, write, create, and delete—that manipulate our FileSystemImage in strictly the same way the provided methods do (using the inode table, the directory map, and the block bitmap). Each function will:\n\n1. Resolve a path by walking from the root (inode 1) through the directory entries.\n2. Check for error conditions (missing file, wrong type, etc.) and raise the appropriate Python exception.\n3. Perform the operation against the in-memory data structures:\n   - read: concatenate the bytes from the inode’s direct blocks, slice out the requested range, and decode as UTF-8.\n   - write: possibly allocate new blocks, write bytes into each block (extending any block’s bytearray), update the inode’s size, and return the mutated image.\n   - create: walk to the parent directory, verify no name clash, create a new inode (directory or file), add the dir entry, and return the image.\n   - delete: walk to the parent directory, find the entry, refuse to delete a nonempty directory, free any file blocks via free_block, remove the inode and directory entry.\n\nPath resolution is shared in each function: split on “/”, ignore empty segments, start at inode=1, and for each segment scan the directory listing of the current inode. That way we guarantee consistent behavior across all operations.  Any error along the way raises the specified exception.\n', config=ConfigFile(read='def read(fs_img: FileSystemImage, name: str, pos: int, length: int) -> str:\n    """Read up to `length` bytes from file `name` starting at offset `pos`."""\n    # Resolve path to inode\n    parts = [p for p in name.split(\'/\') if p]\n    curr = 1\n    for part in parts:\n        if curr not in fs_img.directories:\n            raise NotADirectoryError(f"Inode {curr} is not a directory")\n        for entry in fs_img.directories[curr]:\n            if entry.name == part:\n                curr = entry.inode\n                break\n        else:\n            raise FileNotFoundError(f"Path not found: {name}")\n    inode = fs_img.inodes.get(curr)\n    if inode is None:\n        raise FileNotFoundError(f"Path not found: {name}")\n    if inode.is_dir:\n        raise IsADirectoryError(f"Is a directory: {name}")\n    # Gather full file bytes\n    data = bytearray()\n    for blk_idx in inode.direct_blocks:\n        blk = fs_img.data_blocks[blk_idx] or b\'\'\n        data.extend(blk)\n    # Slice and decode\n    slice_bytes = data[pos:pos+length]\n    return slice_bytes.decode(\'utf-8\')', write='def write(fs_img: FileSystemImage, name: str, pos: int, data: str) -> FileSystemImage:\n    """Write UTF-8 bytes of `data` into file `name` at offset `pos` and return the updated image."""\n    # Resolve path to inode\n    parts = [p for p in name.split(\'/\') if p]\n    curr = 1\n    for part in parts:\n        if curr not in fs_img.directories:\n            raise NotADirectoryError(f"Inode {curr} is not a directory")\n        for entry in fs_img.directories[curr]:\n            if entry.name == part:\n                curr = entry.inode\n                break\n        else:\n            raise FileNotFoundError(f"Path not found: {name}")\n    inode = fs_img.inodes.get(curr)\n    if inode is None:\n        raise FileNotFoundError(f"Path not found: {name}")\n    if inode.is_dir:\n        raise IsADirectoryError(f"Is a directory: {name}")\n    # Prepare data\n    bdata = data.encode(\'utf-8\')\n    end_pos = pos + len(bdata)\n    blk_size = fs_img.superblock.block_size\n    # Ensure enough blocks\n    needed = (end_pos + blk_size - 1) // blk_size\n    while len(inode.direct_blocks) < needed:\n        inode.direct_blocks.append(fs_img.allocate_block())\n    # Write into blocks\n    written = 0\n    offset = pos\n    while written < len(bdata):\n        blk_no = offset // blk_size\n        blk_off = offset % blk_size\n        blk_idx = inode.direct_blocks[blk_no]\n        curr_blk = bytearray(fs_img.data_blocks[blk_idx] or b\'\')\n        # extend block to full size if needed\n        if len(curr_blk) < blk_size:\n            curr_blk.extend(b\'\\x00\' * (blk_size - len(curr_blk)))\n        to_write = min(len(bdata) - written, blk_size - blk_off)\n        curr_blk[blk_off:blk_off+to_write] = bdata[written:written+to_write]\n        fs_img.data_blocks[blk_idx] = bytes(curr_blk)\n        written += to_write\n        offset += to_write\n    # Update inode size\n    if end_pos > inode.size:\n        inode.size = end_pos\n    return fs_img', create='def create(fs_img: FileSystemImage, path: str, is_dir: bool = False) -> FileSystemImage:\n    """Create a new file or directory at `path`, returning the mutated image."""\n    parts = [p for p in path.split(\'/\') if p]\n    if not parts:\n        raise FileExistsError("Cannot create root directory")\n    name = parts[-1]\n    parent_parts = parts[:-1]\n    curr = 1\n    # Walk to parent\n    for part in parent_parts:\n        if curr not in fs_img.directories:\n            raise NotADirectoryError(f"Inode {curr} is not a directory")\n        for entry in fs_img.directories[curr]:\n            if entry.name == part:\n                curr = entry.inode\n                break\n        else:\n            raise FileNotFoundError(f"Parent path not found: {\'/\'.join(parent_parts)}")\n    parent_inode = fs_img.inodes.get(curr)\n    if parent_inode is None or not parent_inode.is_dir:\n        raise NotADirectoryError(f"Not a directory: {\'/\'.join(parent_parts)}")\n    # Check for name clash\n    for entry in fs_img.directories[curr]:\n        if entry.name == name:\n            raise FileExistsError(f"Entry already exists: {path}")\n    # Create inode and add dir entry\n    new_inode = fs_img.create_inode(is_dir)\n    fs_img.add_dir_entry(curr, name, new_inode.ino)\n    return fs_img', delete='def delete(fs_img: FileSystemImage, path: str) -> FileSystemImage:\n    """Delete the entry at `path` and return the updated image."""\n    # Split into parent and name\n    parts = [p for p in path.split(\'/\') if p]\n    if not parts:\n        raise FileNotFoundError("Cannot delete root")\n    name = parts[-1]\n    parent_parts = parts[:-1]\n    curr = 1\n    # Walk to parent directory\n    for part in parent_parts:\n        if curr not in fs_img.directories:\n            raise NotADirectoryError(f"Inode {curr} is not a directory")\n        for entry in fs_img.directories[curr]:\n            if entry.name == part:\n                curr = entry.inode\n                break\n        else:\n            raise FileNotFoundError(f"Parent path not found: {\'/\'.join(parent_parts)}")\n    parent_inode = fs_img.inodes.get(curr)\n    if parent_inode is None or not parent_inode.is_dir:\n        raise NotADirectoryError(f"Not a directory: {\'/\'.join(parent_parts)}")\n    # Locate entry in parent\n    for i, entry in enumerate(fs_img.directories[curr]):\n        if entry.name == name:\n            target_ino = entry.inode\n            break\n    else:\n        raise FileNotFoundError(f"Entry not found: {path}")\n    target_inode = fs_img.inodes.get(target_ino)\n    if target_inode is None:\n        raise FileNotFoundError(f"Inode {target_ino} not found")\n    # If directory, ensure empty\n    if target_inode.is_dir:\n        if fs_img.directories.get(target_ino):\n            raise OSError("Directory not empty")\n        # remove empty dir mapping\n        fs_img.directories.pop(target_ino, None)\n    else:\n        # free all blocks\n        for blk in list(target_inode.direct_blocks):\n            fs_img.free_block(blk)\n    # Remove inode and directory entry\n    fs_img.inodes.pop(target_ino, None)\n    fs_img.directories[curr].pop(i)\n    return fs_img')), 'passed': True, 'evaluation_result': {'delete': True, 'delete_nested': True, 'delete_parent': True, 'fnf_error': True, 'not_directory_error': True, 'dir_not_empty_error': True}, 'score': 100}
