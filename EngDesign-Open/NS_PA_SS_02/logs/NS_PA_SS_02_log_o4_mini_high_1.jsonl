{'completion_tokens': 4678, 'response': Response_structure(reasoning='We need an n-bit Gray‐code sequence generator with a synchronous, active‐low reset and a single rising‐edge clock. To do this:\n\n1. Maintain an internal binary counter of width DATA_WIDTH.  \n2. On each rising edge, if resetn==0, clear both the counter and the Gray‐code output to zero; otherwise increment the counter by one.  \n3. Compute the next Gray code as (counter+1) ^ ((counter+1) >> 1) so that out reflects the new Gray code immediately in the same cycle.  \n4. Parameterize the width via DATA_WIDTH so this works for any positive integer ≥1.  \n\nBelow is the SystemVerilog module implementing these requirements.', code="module model #(\n  parameter DATA_WIDTH = 4\n) (\n  input  logic                    clk,\n  input  logic                    resetn,\n  output logic [DATA_WIDTH-1:0]   out\n);\n\n  // Internal binary counter and combinational next-Gray computation\n  logic [DATA_WIDTH-1:0] count;\n  logic [DATA_WIDTH-1:0] next_gray;\n\n  // Compute Gray code for (count + 1)\n  assign next_gray = (count + 1) ^ ((count + 1) >> 1);\n\n  // Synchronous, active-low reset; update counter and output\n  always_ff @(posedge clk) begin\n    if (!resetn) begin\n      count <= '0;\n      out   <= '0;\n    end else begin\n      count <= count + 1'b1;\n      out   <= next_gray;\n    end\n  end\n\nendmodule"), 'passed': True, 'evaluation_result': {'test0_pass': True, 'test1_pass': True, 'test2_pass': True}, 'score': 100}
