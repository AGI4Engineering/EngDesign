{'completion_tokens': 2413, 'response': Response_structure(reasoning='To meet the spec we need:\n1. A parameter TARGET_WIDTH with default 5.\n2. An internal TARGET_WIDTH-bit register to hold the target pattern loaded synchronously on reset (active-low).\n3. An internal TARGET_WIDTH-bit shift register that remembers the last TARGET_WIDTH serial bits.\n4. A one-cycle pulse output "seen" when the shifted bits exactly match the target.\n5. Fully synchronous logic: on each rising clock edge, if resetn==0 we load init into target_reg, clear shift_reg, drive seen=0; otherwise we shift in the new bit and compare.\n\nImplementation details:\n- Use always_ff @(posedge clk) for sequential logic.\n- Precompute the next shift register value (next_shift) combinationally so we can compare it in the same cycle.\n- Non-blocking assigns (<=) inside the always_ff block ensure proper register behavior.\n- The init input is the same width as TARGET_WIDTH, and any unused high-order bits are naturally zero if init is smaller.\n- The comparison next_shift == target_reg generates a one-cycle pulse when they match.\n\nStep by step:\n1. Declare module with parameter and ports.\n2. Declare internal registers target_reg, shift_reg, and a wire next_shift.\n3. Assign next_shift = {shift_reg[TARGET_WIDTH-2:0], din}.\n4. In always_ff, if (!resetn) load target_reg<=init, clear shift_reg and seen; else shift_reg<=next_shift and seen<=(next_shift==target_reg).\n5. Endmodule.', code="module model #(\n    parameter TARGET_WIDTH = 5\n) (\n    input  logic                     clk,     // clock signal\n    input  logic                     resetn,  // synchronous, active-low reset\n    input  logic [TARGET_WIDTH-1:0] init,    // target sequence, loaded on reset\n    input  logic                     din,     // serial input bit\n    output logic                     seen     // one-cycle pulse on match\n);\n\n    // Internal registers\n    logic [TARGET_WIDTH-1:0] target_reg; // holds the loaded target sequence\n    logic [TARGET_WIDTH-1:0] shift_reg;  // shift register for incoming bits\n    logic [TARGET_WIDTH-1:0] next_shift; // combinational next value of shift_reg\n\n    // Compute next shift register value by shifting in din\n    assign next_shift = {shift_reg[TARGET_WIDTH-2:0], din};\n\n    // Synchronous logic with active-low reset\n    always_ff @(posedge clk) begin\n        if (!resetn) begin\n            // On reset: load target, clear shift register, clear seen\n            target_reg <= init;\n            shift_reg  <= '0;\n            seen        <= 1'b0;\n        end else begin\n            // Normal operation: shift in new bit\n            shift_reg <= next_shift;\n            // Pulse seen when shifted bits match target\n            seen <= (next_shift == target_reg);\n        end\n    end\n\nendmodule\n"), 'passed': True, 'evaluation_result': {'test0_pass': True, 'test1_pass': True, 'test2_pass': True}, 'score': 100}
