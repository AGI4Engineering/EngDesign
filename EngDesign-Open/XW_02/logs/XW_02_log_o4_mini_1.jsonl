{'completion_tokens': 2029, 'response': Response_structure(reasoning='To implement the write operation, we need to:\n\n1. Resolve the path “name” against the in‐memory directory tree, starting at inode 1 (root).  Split the path on “/”, traverse each component, verifying directories and raising FileNotFoundError or NotADirectoryError as needed.\n\n2. Locate the final component as a DirEntry in its parent directory.  If missing, raise FileNotFoundError; if it refers to a directory inode, raise IsADirectoryError.\n\n3. Verify the byte offset “pos” is within [0, inode.size].  Otherwise raise ValueError.\n\n4. Encode the input string to UTF-8 bytes.  Compute the file’s end position after writing, and determine how many blocks are needed by rounding up (end_offset / block_size).\n\n5. Allocate new blocks via fs_img.allocate_block() until inode.direct_blocks has enough entries.  Each block is initialized empty by allocate_block().\n\n6. Iterate over the target byte range, locating the corresponding block index and in‐block offset.  Convert the existing block bytes to a mutable bytearray, overwrite the appropriate slice with the new data, then store the updated bytes back in fs_img.data_blocks[block_idx].\n\n7. After all bytes are written, update inode.size to the new maximum of old size vs end_offset.\n\n8. Return the same fs_img object so that the caller can inspect its inodes, directories, and data_blocks for correctness.', config=ConfigFile(write='def write(fs_img: FileSystemImage, name: str, pos: int, data: str) -> FileSystemImage:\n    # 1. Resolve the path\n    components = [c for c in name.split(\'/\') if c]\n    curr_inode = 1  # start at root\n    # traverse all but final component\n    for comp in components[:-1]:\n        entries = fs_img.directories.get(curr_inode, [])\n        for entry in entries:\n            if entry.name == comp:\n                inode_obj = fs_img.inodes[entry.inode]\n                if not inode_obj.is_dir:\n                    raise NotADirectoryError(f"{comp} is not a directory")\n                curr_inode = entry.inode\n                break\n        else:\n            raise FileNotFoundError(f"Directory {comp} not found")\n    # 2. Find target file entry\n    filename = components[-1] if components else \'\'\n    entries = fs_img.directories.get(curr_inode, [])\n    for entry in entries:\n        if entry.name == filename:\n            inode_obj = fs_img.inodes[entry.inode]\n            break\n    else:\n        raise FileNotFoundError(f"File {filename} not found")\n    if inode_obj.is_dir:\n        raise IsADirectoryError(f"{filename} is a directory")\n    # 3. Validate position\n    if pos < 0 or pos > inode_obj.size:\n        raise ValueError("Invalid write position")\n    # 4. Prepare data and block calculations\n    bdata = data.encode(\'utf-8\')\n    end_offset = pos + len(bdata)\n    bs = fs_img.superblock.block_size\n    needed = (end_offset + bs - 1) // bs\n    # 5. Allocate new blocks if needed\n    while len(inode_obj.direct_blocks) < needed:\n        inode_obj.direct_blocks.append(fs_img.allocate_block())\n    # 6. Write into blocks\n    written = 0\n    offset = pos\n    while written < len(bdata):\n        blk_idx = inode_obj.direct_blocks[offset // bs]\n        chunk_off = offset % bs\n        to_write = min(bs - chunk_off, len(bdata) - written)\n        existing = fs_img.data_blocks[blk_idx] or b\'\'\n        mb = bytearray(existing)\n        mb[chunk_off:chunk_off+to_write] = bdata[written:written+to_write]\n        fs_img.data_blocks[blk_idx] = bytes(mb)\n        written += to_write\n        offset += to_write\n    # 7. Update size\n    inode_obj.size = max(inode_obj.size, end_offset)\n    return fs_img')), 'passed': False, 'evaluation_result': {'write': 'correctly raised error for non-existent file', 'read': 'Error in read content check '}, 'score': 80}
