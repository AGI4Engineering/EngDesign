{'completion_tokens': 2248, 'response': Response_structure(reasoning="Below is a sample implementation for the 'write' function. It includes:\n1. A helper routine to find the file's inode (assuming a single-level lookup based on the provided name; in more complex scenarios, you could parse subdirectories).\n2. Required checks for file existence, directory checks, and valid offset.\n3. Logic to extend the file (allocate blocks) if the write goes beyond the current file size.\n4. Iteration and calculation of which data block to write to.\n5. Writing (overwriting/appending) the relevant portion of data in each block.\n6. Finally, updating the inode size.\n\nPlease review and verify correctness for your specific use case.\n", config=ConfigFile(write='def write(fs_img: FileSystemImage, name: str, pos: int, data: str) -> FileSystemImage:\\n    """\\n    Write the UTF‑8 encoded bytes of `data` into the file called `name`\\n    in the given FileSystemImage, starting at byte offset `pos`. Return\\n    the updated FileSystemImage so that its blocks and inode metadata\\n    can be inspected for correctness.\\n\\n    Parameters:\\n    - fs_img:   the FileSystemImage instance containing inodes, directories,\\n                and data blocks.\\n    - name:     an absolute or relative path to the target file within `fs_img`.\\n    - pos:      the byte offset within the file at which to begin writing.\\n    - data:     a Python string whose UTF‑8 encoding will be written.\\n\\n    Returns:\\n    - The same FileSystemImage instance (`fs_img`), mutated to reflect the\\n      writes (updated data_blocks and inode.size).\\n\\n    Behavior:\\n    1. If the file `name` does not exist or refers to a directory, raise\\n       `FileNotFoundError` or `IsADirectoryError` respectively.\\n    2. If `pos` is negative or greater than the file’s current size, raise\\n       `ValueError`.\\n    3. Encode `data` as UTF‑8 bytes.\\n    4. If writing beyond the current end of file, extend the file:\\n       - Allocate new blocks via `fs_img.allocate_block()` as needed.\\n       - Update the inode’s `direct_blocks` list accordingly.\\n    5. Compute which blocks and byte‐ranges within them correspond to\\n       the target file range `[pos, pos + len(bytes))`.\\n    6. Overwrite or append bytes in `fs_img.data_blocks[block_idx]` per block.\\n    7. Update the inode’s `size` to `max(old_size, pos + len(bytes))`.\\n    8. Return the mutated `fs_img` so that test harnesses can inspect\\n       its `data_blocks` and `inodes` for correctness.\\n    """\\n    # Helper function to find an inode by file name (single-level search)\\n    def find_inode_by_name(fs_img: FileSystemImage, filename: str) -> int:\\n        # Search all directories for a matching entry\\n        for dir_ino, entries in fs_img.directories.items():\\n            for entry in entries:\\n                if entry.name == filename:\\n                    return entry.inode\\n        return -1  # not found\\n\\n    # 1. Find the inode number from the filename\\n    inode_num = find_inode_by_name(fs_img, name)\\n    if inode_num == -1:\\n        raise FileNotFoundError(f"File \'{name}\' does not exist.")\\n\\n    inode = fs_img.inodes[inode_num]\\n\\n    # 1. Check if it\'s actually a directory\\n    if inode.is_dir:\\n        raise IsADirectoryError(f"\'{name}\' is a directory.")\\n\\n    # 2. Check pos validity\\n    if pos < 0 or pos > inode.size:\\n        raise ValueError("Invalid \'pos\': must be within [0, file size].")\\n\\n    # 3. Encode data as UTF-8\\n    write_bytes = data.encode(\'utf-8\')\\n    write_len = len(write_bytes)\\n\\n    # 4. Extend file if needed\\n    # We know the file\'s current size is inode.size\\n    # If pos+write_len > inode.size, we need to fill out the difference\\n    old_size = inode.size\\n    new_size = max(old_size, pos + write_len)\\n    block_size = fs_img.superblock.block_size\\n\\n    # Number of blocks currently allocated\\n    current_block_count = len(inode.direct_blocks)\\n    # Number of blocks needed for new_size\\n    needed_block_count = (new_size + block_size - 1) // block_size\\n\\n    # Allocate additional blocks if necessary\\n    while current_block_count < needed_block_count:\\n        new_block_idx = fs_img.allocate_block()\\n        inode.direct_blocks.append(new_block_idx)\\n        current_block_count += 1\\n\\n    # 5. Compute which blocks to write to\\n    # We\'ll write starting at \'pos\', continuing for \'write_len\' bytes\\n\\n    bytes_written = 0\\n    remaining = write_len\\n    current_offset = pos\\n\\n    # While we still have bytes to write\\n    while remaining > 0:\\n        # Identify which block index in the inode.direct_blocks we need\\n        block_index_within_file = current_offset // block_size\\n        block_idx = inode.direct_blocks[block_index_within_file]\\n\\n        # Within that block, the starting position\\n        start_in_block = current_offset % block_size\\n\\n        # We can write up to the end of this block\\n        space_in_block = block_size - start_in_block\\n        to_write_now = min(remaining, space_in_block)\\n\\n        # Fetch current block content\\n        block_content = fs_img.data_blocks[block_idx]\\n        if block_content is None:\\n            block_content = b\'\'\\n\\n        # Ensure block_content is at least block_size in length, or ensure we can slice properly\\n        if len(block_content) < block_size:\\n            # Extend with zeros if needed\\n            block_content = block_content + b\'\\0\' * (block_size - len(block_content))\\n\\n        # Overwrite the specific region\\n        new_block_content = (\\n            block_content[:start_in_block]\\n            + write_bytes[bytes_written:bytes_written + to_write_now]\\n            + block_content[start_in_block + to_write_now:]\\n        )\\n\\n        # Update the data block\\n        fs_img.data_blocks[block_idx] = new_block_content\\n\\n        # Update counters\\n        bytes_written += to_write_now\\n        remaining -= to_write_now\\n        current_offset += to_write_now\\n\\n    # 7. Update the inode size\\n    inode.size = new_size\\n\\n    # 8. Return the mutated fs_img\\n    return fs_img\\n')), 'passed': False, 'evaluation_result': {'read': 'Error in code execution: unexpected character after line continuation character (<string>, line 1)'}, 'score': 0}
