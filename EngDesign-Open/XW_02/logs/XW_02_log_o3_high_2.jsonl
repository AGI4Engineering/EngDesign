{'completion_tokens': 3012, 'response': Response_structure(reasoning='We need to supply a JSON object that follows the Response_structure schema.  That object must contain:\n  • a detailed explanation of what we are doing (field "reasoning")\n  • a "config" object that itself contains a single property called "write" – a string holding a complete implementation of the required write() routine.\n\nThe implementation must\n  1. resolve a (possibly absolute) pathname to its inode by walking the directory-tree stored in FileSystemImage.directories starting from inode 1 (the root).\n  2. validate that the inode exists, is not a directory and that the supplied offset is legal (0 ≤ pos ≤ file-size).\n  3. UTF-8-encode the supplied text.\n  4. Work out how many blocks are needed once the write is finished and allocate extra blocks if necessary (using fs_img.allocate_block()).\n  5. For every affected block compute the in-block byte range and copy the appropriate slice of the encoded data into fs_img.data_blocks[block_idx].  The helper guarantees that blocks always stay exactly superblock.block_size bytes long (padding with \\x00 when first touched) so we can update them in-place easily.\n  6. Finally update inode.size and return the mutated fs_img so that outside test-code can inspect it.\n\nThe code string below is valid, self-contained Python that relies only on the classes already provided in the prompt.', config=ConfigFile(write='def write(fs_img: FileSystemImage, name: str, pos: int, data: str) -> FileSystemImage:\n    """Write the UTF-8 encoded bytes of ``data`` into file ``name`` beginning at\n    byte offset ``pos``.  The FileSystemImage is updated in-place and returned.\n\n    Behaviour follows the specification given in the prompt.\n    """\n\n    # ---------------------------------------------------------------------\n    # 1. Helper – resolve a pathname to an inode number (raises FileNotFoundError)\n    # ---------------------------------------------------------------------\n    def _resolve_path(fs: FileSystemImage, path: str) -> int:\n        """Return the inode number addressed by *path* (absolute or relative).\n        The function walks the directory hierarchy starting at the root\n        (inode 1).  Relative paths are treated as relative to the root as well\n        (there is no notion of a current working directory in this model).\n        """\n\n        # Root inode is conventionally 1\n        ROOT_INO = 1\n\n        # An empty string or \'/\' refers to the root directory itself\n        if not path or path == "/":\n            return ROOT_INO\n\n        # Decide where to start and split into components\n        components = path.strip("/").split("/") if path.startswith("/") else path.split("/")\n\n        cur_ino = ROOT_INO\n        for part in components:\n            # The current inode must be a directory and present in fs.directories\n            if cur_ino not in fs.directories:\n                raise FileNotFoundError(path)\n\n            next_ino: int | None = None\n            for entry in fs.directories[cur_ino]:\n                if entry.name == part:\n                    next_ino = entry.inode\n                    break\n            if next_ino is None:\n                raise FileNotFoundError(path)\n            cur_ino = next_ino\n        return cur_ino\n\n    # ------------------------------------------------------------------\n    # 2. Look the file up and run the required validations\n    # ------------------------------------------------------------------\n    target_ino = _resolve_path(fs_img, name)\n    inode = fs_img.inodes.get(target_ino)\n    if inode is None:\n        raise FileNotFoundError(name)\n    if inode.is_dir:\n        raise IsADirectoryError(name)\n    if pos < 0 or pos > inode.size:\n        raise ValueError("pos is out of range")\n\n    # ------------------------------------------------------------------\n    # 3. Prepare data to be written and calculate required storage\n    # ------------------------------------------------------------------\n    payload = data.encode("utf-8")\n    payload_len = len(payload)\n    new_file_size = max(inode.size, pos + payload_len)\n\n    block_size = fs_img.superblock.block_size\n    required_blocks = (new_file_size + block_size - 1) // block_size\n\n    # ------------------------------------------------------------------\n    # 4. Allocate extra blocks if the file is growing\n    # ------------------------------------------------------------------\n    while len(inode.direct_blocks) < required_blocks:\n        new_block_index = fs_img.allocate_block()\n        inode.direct_blocks.append(new_block_index)\n\n    # ------------------------------------------------------------------\n    # 5. Perform the actual write, block by block\n    # ------------------------------------------------------------------\n    write_offset = 0  # index into *payload*\n    while write_offset < payload_len:\n        file_off = pos + write_offset\n        block_no_in_file = file_off // block_size\n        start_in_block = file_off % block_size\n\n        global_block_idx = inode.direct_blocks[block_no_in_file]\n\n        # Ensure the block has exactly block_size bytes (fill with 0 on first use)\n        existing = fs_img.data_blocks[global_block_idx] or b""\n        if len(existing) < block_size:\n            existing = existing + b"\\x00" * (block_size - len(existing))\n        buf = bytearray(existing)\n\n        # How many bytes from the payload go into this block?\n        chunk = min(payload_len - write_offset, block_size - start_in_block)\n        buf[start_in_block:start_in_block + chunk] = payload[write_offset:write_offset + chunk]\n\n        fs_img.data_blocks[global_block_idx] = bytes(buf)\n        write_offset += chunk\n\n    # ------------------------------------------------------------------\n    # 6. Update inode metadata and return the mutated filesystem image\n    # ------------------------------------------------------------------\n    inode.size = new_file_size\n    return fs_img')), 'passed': False, 'evaluation_result': {'write': 'correctly raised error for non-existent file', 'read': 'Error in read content check '}, 'score': 80}
