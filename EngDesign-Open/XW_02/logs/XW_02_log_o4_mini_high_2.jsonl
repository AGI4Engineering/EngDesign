{'completion_tokens': 6482, 'response': Response_structure(reasoning='We implement the write operation by resolving the file path within the image, checking that the target exists and is not a directory, and that the write offset is valid. We then encode the input data to UTF-8 bytes and calculate the new file size and the range of blocks needed. If necessary, we allocate additional blocks from the superblock’s free bitmap. We then iterate over each affected block, compute the correct slice offsets, pad existing block contents as needed, and overwrite or append the new data. Finally, we update the inode’s size to reflect any growth and return the modified FileSystemImage. Error cases such as negative positions, non-existent files, and attempts to write to directories raise the appropriate exceptions. This ensures correct behavior per the specification.', config=ConfigFile(write="def write(fs_img: FileSystemImage, name: str, pos: int, data: str) -> FileSystemImage:\n    def _resolve_path(path):\n        cur = 1\n        if path.startswith('/'):\n            parts = path.strip('/').split('/')\n        else:\n            parts = path.split('/')\n        for part in parts:\n            if not part:\n                continue\n            if cur not in fs_img.directories:\n                raise FileNotFoundError('Not a directory: {}'.format(cur))\n            found = False\n            for entry in fs_img.directories[cur]:\n                if entry.name == part:\n                    cur = entry.inode\n                    found = True\n                    break\n            if not found:\n                raise FileNotFoundError('File not found: {}'.format(path))\n        return cur\n    ino = _resolve_path(name)\n    inode = fs_img.inodes.get(ino)\n    if inode is None:\n        raise FileNotFoundError('File not found: {}'.format(name))\n    if inode.is_dir:\n        raise IsADirectoryError('Is a directory: {}'.format(name))\n    if pos < 0 or pos > inode.size:\n        raise ValueError('Invalid position: {}'.format(pos))\n    data_bytes = data.encode('utf-8')\n    old_size = inode.size\n    new_size = pos + len(data_bytes)\n    block_size = fs_img.superblock.block_size\n    start_block = pos // block_size\n    end_block = (new_size - 1) // block_size if new_size > 0 else 0\n    while len(inode.direct_blocks) <= end_block:\n        inode.direct_blocks.append(fs_img.allocate_block())\n    offset = pos\n    idx_data = 0\n    remaining = len(data_bytes)\n    for blk in range(start_block, end_block + 1):\n        phys = inode.direct_blocks[blk]\n        block_start = blk * block_size\n        start_in_blk = max(offset - block_start, 0)\n        end_in_blk = min(block_size, start_in_blk + remaining)\n        chunk = data_bytes[idx_data:(idx_data + end_in_blk - start_in_blk)]\n        content = fs_img.data_blocks[phys] or b''\n        if len(content) < end_in_blk:\n            content = content.ljust(end_in_blk, bytes([0]))\n        new_content = content[:start_in_blk] + chunk + content[end_in_blk:]\n        fs_img.data_blocks[phys] = new_content\n        written = end_in_blk - start_in_blk\n        remaining -= written\n        idx_data += written\n        offset += written\n    inode.size = new_size if new_size > old_size else old_size\n    return fs_img")), 'passed': False, 'evaluation_result': {'write': 'correctly raised error for non-existent file', 'read': 'Error in read content check '}, 'score': 80}
