{'completion_tokens': 2430, 'response': Response_structure(reasoning='Step-by-step approach for implementing the required write() operation.\n\n1. Path resolution\n   • Split the supplied pathname on \'/\'.\n   • Start from the root directory (conventionally inode 1) and walk the components except the final one.  For each component, look it up in the current directory’s DirEntry list; verify the entry exists and that its inode is a directory.\n   • Finally locate the DirEntry for the target file in the parent directory.  Raise FileNotFoundError if it is missing; raise IsADirectoryError if the inode found is itself a directory.\n\n2. Parameter validation\n   • Reject negative offsets.\n   • Reject offsets larger than the current file size ("holes" are not supported by the spec).\n\n3. Data preparation\n   • Encode the provided text to UTF-8 bytes.\n   • Compute the byte-range that will be written:  [pos, pos + len(bytes)).\n\n4. Ensure enough data blocks exist\n   • Derive the number of blocks required for the new logical file size (ceiling(end_offset / block_size)).\n   • While the inode’s direct_blocks list is shorter than this, call fs_img.allocate_block() and append the returned block index.\n\n5. Perform the write\n   • Iterate over the byte sequence, calculating for each iteration the destination block number, the in-block offset, and how many bytes can be copied into that block.\n   • If the corresponding fs_img.data_blocks[block_idx] is None (never written before), initialise it to a zero-filled bytes object of length block_size so we can support partial overwrites cleanly.\n   • Write the slice, then move the cursors forward until all bytes are copied.\n\n6. Update metadata\n   • Set inode.size to max(old_size, end_offset).\n\n7. Return the mutated FileSystemImage (the function works in-place but the caller may wish to chain or inspect it).\n\nThe implementation below follows precisely this recipe, adhering to the public helpers allocate_block(), etc., so the overall image integrity is preserved.', config=ConfigFile(write='def write(fs_img: "FileSystemImage", name: str, pos: int, data: str) -> "FileSystemImage":\n    """Write UTF-8 bytes of `data` into file `name` at offset `pos` and return the updated image."""\n    import math\n\n    # ------- 1. Resolve pathname to a file inode -------\n    if name == "" or name == "/":\n        raise IsADirectoryError("Path refers to root directory, not a file")\n\n    # Break path into components, ignoring leading \'/\' and duplicate slashes\n    components = [c for c in name.split(\'/\') if c]\n    parent_ino = 1  # convention: inode 1 is the root directory\n\n    # Walk all components except the last to reach the parent directory\n    for comp in components[:-1]:\n        dir_entries = fs_img.directories.get(parent_ino)\n        if dir_entries is None:\n            raise NotADirectoryError(f"Inode {parent_ino} is not a directory")\n\n        next_ino = None\n        for de in dir_entries:\n            if de.name == comp:\n                next_ino = de.inode\n                break\n        if next_ino is None:\n            raise FileNotFoundError(f"Component \'{comp}\' not found in path \'{name}\'")\n\n        inode_obj = fs_img.inodes[next_ino]\n        if not inode_obj.is_dir:\n            raise NotADirectoryError(f"\'{comp}\' in path \'{name}\' is not a directory")\n        parent_ino = next_ino\n\n    # The final component must exist and be a file\n    filename = components[-1]\n    target_ino = None\n    for de in fs_img.directories.get(parent_ino, []):\n        if de.name == filename:\n            target_ino = de.inode\n            break\n    if target_ino is None:\n        raise FileNotFoundError(f"File \'{name}\' does not exist")\n\n    inode = fs_img.inodes[target_ino]\n    if inode.is_dir:\n        raise IsADirectoryError(f"\'{name}\' is a directory, not a file")\n\n    # ------- 2. Validate write position -------\n    if pos < 0 or pos > inode.size:\n        raise ValueError("Position outside current file size")\n\n    # ------- 3. Prepare data -------\n    byte_data = data.encode("utf-8")\n    data_len = len(byte_data)\n    if data_len == 0:\n        return fs_img  # nothing to do\n    end_offset = pos + data_len\n\n    # ------- 4. Ensure enough blocks are allocated -------\n    bs = fs_img.superblock.block_size\n    needed_blocks = math.ceil(end_offset / bs)\n    while len(inode.direct_blocks) < needed_blocks:\n        inode.direct_blocks.append(fs_img.allocate_block())\n\n    # ------- 5. Perform the block-wise write -------\n    remaining = data_len\n    buf_idx = 0  # index into byte_data\n    curr_offset = pos\n\n    while remaining > 0:\n        block_no = curr_offset // bs\n        in_block_off = curr_offset % bs\n        block_idx = inode.direct_blocks[block_no]\n\n        # Initialisation of an untouched block\n        if fs_img.data_blocks[block_idx] is None:\n            fs_img.data_blocks[block_idx] = b"\\x00" * bs\n\n        block_bytes = bytearray(fs_img.data_blocks[block_idx])\n        writable = min(remaining, bs - in_block_off)\n        block_bytes[in_block_off:in_block_off + writable] = byte_data[buf_idx:buf_idx + writable]\n        fs_img.data_blocks[block_idx] = bytes(block_bytes)\n\n        # Advance cursors\n        curr_offset += writable\n        buf_idx += writable\n        remaining -= writable\n\n    # ------- 6. Update inode size -------\n    if end_offset > inode.size:\n        inode.size = end_offset\n\n    # ------- 7. Return mutated image -------\n    return fs_img')), 'passed': False, 'evaluation_result': {'write': 'correctly raised error for non-existent file', 'read': 'Error in read content check '}, 'score': 80}
