{'completion_tokens': 3547, 'response': Response_structure(reasoning="The `write` function needs to modify a file's content within a simulated filesystem image. The process involves several steps:\n1.  **Path Resolution and Validation**: A helper function `_get_inode_by_path_helper` is defined (nested for self-containment) to find the inode corresponding to the given `name`. This helper handles absolute paths (assuming paths not starting with '/' are relative to the root, effectively making them absolute from root like `/name`). It traverses the directory structure starting from inode 1 (assumed root). It raises `FileNotFoundError` if any path component is not found or if the root directory is misconfigured. It raises `NotADirectoryError` if a path component that should be a directory is not.\n2.  **Initial Checks in `write`**: \n    *   The `name` parameter is checked for emptiness; if empty, `FileNotFoundError` is raised.\n    *   The inode found by the helper is then checked: if it represents a directory (`inode.is_dir == True`), `IsADirectoryError` is raised, as per requirements.\n    *   The `pos` (write position) is validated: if `pos < 0` or `pos > inode.size` (current file size), a `ValueError` is raised. Writing at `pos == inode.size` (end of file) is permitted.\n3.  **Data Preparation**: The input `data` string is encoded into UTF-8 bytes. If the resulting byte string is empty, the function returns immediately as there's nothing to write.\n4.  **File Extension and Block Allocation**: \n    *   The total size required for the file after the write (`required_file_size_after_write = pos + len(bytes_to_write)`) is calculated.\n    *   If this required size exceeds the current capacity of the file (based on `inode.direct_blocks` and `fs_img.superblock.block_size`), new data blocks are allocated.\n    *   `fs_img.allocate_block()` is called iteratively for each new block needed. Each new block index is appended to `inode.direct_blocks`.\n    *   If `allocate_block()` fails (e.g., no free blocks), it's expected to raise a `RuntimeError`, which is propagated.\n5.  **Writing Data to Blocks**: \n    *   The function iterates, writing chunks of `bytes_to_write` into the appropriate data blocks.\n    *   In each iteration: \n        *   It calculates which file block (`block_index_in_file`) and what offset within that physical block (`offset_within_physical_block`) corresponds to the `current_write_pos_in_file`.\n        *   The actual data block ID is retrieved from `inode.direct_blocks[block_index_in_file]`.\n        *   The existing content of this physical data block is fetched (it's `b''` if newly allocated by `fs_img.allocate_block()`).\n        *   The number of bytes to write into this specific block in this iteration (`num_bytes_to_write_to_this_block`) is determined. This is the minimum of the space remaining in the current physical block and the total bytes remaining to be written from the input `data`.\n        *   The corresponding chunk of data (`data_chunk_for_this_block`) is sliced from `bytes_to_write`.\n        *   The physical block's content (as a `bytearray` for easy modification) is updated by placing `data_chunk_for_this_block` at `offset_within_physical_block`. This handles overwriting existing data or appending. If `offset_within_physical_block` is beyond the current data in the block, the gap is filled with null bytes by extending the `bytearray` first.\n        *   The modified `bytearray` is converted back to `bytes` and stored in `fs_img.data_blocks[actual_data_block_id]`, ensuring it's truncated to `block_size` (though logic should prevent exceeding this).\n    *   Pointers for `bytes_written_from_input` and `current_write_pos_in_file` are advanced.\n6.  **Updating Inode Metadata**: After all bytes are written, `inode.size` is updated to `max(inode.size, required_file_size_after_write)` to reflect the new file size.\n7.  **Return Value**: The mutated `fs_img` is returned, allowing inspection of its state.\n\nThe class definitions for `FileSystemImage`, `Inode`, `DirEntry`, `SuperBlock` and methods like `allocate_block` are assumed to be available in the execution scope, as provided in the problem description.", config=ConfigFile(write='def write(fs_img: FileSystemImage, name: str, pos: int, data: str) -> FileSystemImage:\n    """Write UTFâ€‘8 bytes of `data` into file `name` at offset `pos` and return the updated image."""\n\n    # Helper function for path resolution (nested to be self-contained)\n    def _get_inode_by_path_helper(fs_img_inner: FileSystemImage, path_inner: str) -> Inode:\n        processed_path = path_inner\n        if not path_inner.startswith("/"):\n            processed_path = "/" + path_inner # Treat non-absolute as relative to root\n        \n        # Normalize path: remove trailing slashes, handle multiple slashes like /foo//bar\n        # Path like "/foo/bar" -> components = ["foo", "bar"]\n        # Path like "/" or "//" -> components = [] (normalized_path_stripped = "" after strip)\n        # Path like "/foo/" -> components = ["foo"]\n        normalized_path_stripped = processed_path.strip("/")\n        components = [comp for comp in normalized_path_stripped.split("/") if comp]\n\n        current_inode_num = 1 # Start from root directory (inode 1)\n\n        # Check root directory existence and type upfront\n        if 1 not in fs_img_inner.inodes:\n            raise FileNotFoundError(f"Root directory (inode 1) does not exist.")\n        root_inode_check = fs_img_inner.inodes[1]\n        if not root_inode_check.is_dir:\n            raise NotADirectoryError(f"Root (inode 1) is not a directory.")\n\n        # Traverse path components\n        # current_inode_num starts as root. Each iteration, it becomes the inode of the next component.\n        for i, component_name in enumerate(components):\n            # The inode we are about to list entries from (current_inode_num) must be a directory.\n            # This was fs_img.inodes[found_entry.inode] from the previous iteration, or root for the first component.\n            current_dir_inode = fs_img_inner.inodes.get(current_inode_num)\n            \n            # This check ensures that the component resolved in the *previous* step (which is now current_dir_inode) is indeed a directory.\n            # For i=0, current_dir_inode is root_inode_check, which is already verified.\n            if not current_dir_inode.is_dir: # Note: current_dir_inode cannot be None due to previous checks and successful lookups.\n                # components[i-1] is the name of the path segment that turned out not to be a directory.\n                # Its full path is /<comp[0]>/.../<comp[i-1]>\n                path_of_non_dir_component = "/" + "/".join(components[:i])\n                raise NotADirectoryError(f"Path component \'{components[i-1]}\' (full path \'{path_of_non_dir_component}\') is not a directory.")\n\n            dir_entries = fs_img_inner.directories.get(current_inode_num)\n            if dir_entries is None: # Should be consistent with inode.is_dir for a valid FS structure\n                path_so_far = "/" + "/".join(components[:i])\n                raise FileNotFoundError(f"Directory entries for inode {current_inode_num} (path \'{path_so_far}\') not found, implies inconsistent filesystem.")\n\n            found_entry = None\n            for entry in dir_entries:\n                if entry.name == component_name:\n                    found_entry = entry\n                    break\n            \n            if found_entry is None:\n                parent_path_str = "/" + "/".join(components[:i]) if i > 0 else "/"\n                raise FileNotFoundError(f"Component \'{component_name}\' not found in directory \'{parent_path_str}\'.")\n            \n            current_inode_num = found_entry.inode # Move to the next inode in the path\n\n        # After loop, current_inode_num is the target inode\'s number\n        target_inode = fs_img_inner.inodes.get(current_inode_num)\n        if not target_inode: # Should not happen if DirEntry points to valid inodes\n            raise FileNotFoundError(f"Target inode {current_inode_num} for path \'{path_inner}\' not found in inodes table (dangling reference).")\n        \n        return target_inode\n\n    # Main logic of write function\n    if not name: # Requirement: name must be non-empty\n        raise FileNotFoundError("File name cannot be empty.")\n\n    try:\n        inode = _get_inode_by_path_helper(fs_img, name)\n    except FileNotFoundError as e:\n        # Re-raise with the original name, as helper might use a normalized path string for its internal messages\n        raise FileNotFoundError(f"File \'{name}\' not found or path is invalid. Detail: {e}")\n    except NotADirectoryError as e:\n        raise NotADirectoryError(f"A component of path \'{name}\' is not a directory. Detail: {e}")\n\n    # Behavior 1 (continued): Check if it\'s a directory\n    if inode.is_dir:\n        raise IsADirectoryError(f"\'{name}\' is a directory, not a file.")\n\n    # Behavior 2: Position check\n    if pos < 0 or pos > inode.size:\n        raise ValueError(f"Position {pos} is out of bounds for file \'{name}\' of size {inode.size}.")\n\n    # Behavior 3: Encode data to UTF-8\n    bytes_to_write = data.encode(\'utf-8\')\n    len_bytes_to_write = len(bytes_to_write)\n\n    if len_bytes_to_write == 0: # Optimization: nothing to write\n        return fs_img\n\n    # Behavior 4: File Extension (Block Allocation)\n    block_size = fs_img.superblock.block_size\n    required_file_size_after_write = pos + len_bytes_to_write\n    \n    current_blocks_allocated_count = len(inode.direct_blocks)\n    current_capacity_bytes = current_blocks_allocated_count * block_size\n    \n    if required_file_size_after_write > current_capacity_bytes:\n        additional_storage_needed_bytes = required_file_size_after_write - current_capacity_bytes\n        num_new_blocks_to_allocate = (additional_storage_needed_bytes + block_size - 1) // block_size\n        \n        for _ in range(num_new_blocks_to_allocate):\n            try:\n                new_block_idx = fs_img.allocate_block() # This also initializes the block to b\'\'\n                inode.direct_blocks.append(new_block_idx)\n            except RuntimeError as e: # Typically "No free blocks available"\n                raise RuntimeError(f"Failed to extend file \'{name}\': Not enough space. Detail: {e}") from e\n    \n    # Behavior 5 & 6: Write data to blocks\n    bytes_written_from_input = 0  # How many bytes from \'bytes_to_write\' have been processed\n    current_write_pos_in_file = pos # The current absolute byte offset in the file being written to\n\n    while bytes_written_from_input < len_bytes_to_write:\n        block_index_in_file = current_write_pos_in_file // block_size # Which block of the file (0th, 1st, ...)\n        offset_within_physical_block = current_write_pos_in_file % block_size   # Offset within that data block\n\n        actual_data_block_id = inode.direct_blocks[block_index_in_file]\n        # fs_img.data_blocks[actual_data_block_id] was set to b\'\' by allocate_block if new, or contains existing data.\n        physical_block_content_bytes = fs_img.data_blocks[actual_data_block_id] or b\'\'\n        physical_block_content = bytearray(physical_block_content_bytes)\n        \n        space_available_in_physical_block = block_size - offset_within_physical_block\n        remaining_bytes_from_input_to_write = len_bytes_to_write - bytes_written_from_input\n        \n        num_bytes_to_write_to_this_block = min(space_available_in_physical_block, remaining_bytes_from_input_to_write)\n        data_chunk_for_this_block = bytes_to_write[bytes_written_from_input : bytes_written_from_input + num_bytes_to_write_to_this_block]\n        \n        # Modify the physical block\'s content\n        # Ensure physical_block_content is long enough if writing starts past its current effective length\n        if offset_within_physical_block > len(physical_block_content):\n            physical_block_content.extend(b\'\\x00\' * (offset_within_physical_block - len(physical_block_content)))\n            \n        end_offset_for_slice = offset_within_physical_block + num_bytes_to_write_to_this_block\n        physical_block_content[offset_within_physical_block : end_offset_for_slice] = data_chunk_for_this_block\n        \n        fs_img.data_blocks[actual_data_block_id] = bytes(physical_block_content[:block_size])\n\n        bytes_written_from_input += num_bytes_to_write_to_this_block\n        current_write_pos_in_file += num_bytes_to_write_to_this_block\n\n    # Behavior 7: Update Inode Size\n    inode.size = max(inode.size, required_file_size_after_write)\n    \n    # Behavior 8: Return mutated fs_img\n    return fs_img')), 'passed': False, 'evaluation_result': {'write': 'correctly raised error for non-existent file', 'read': 'Error in read content check '}, 'score': 80}
