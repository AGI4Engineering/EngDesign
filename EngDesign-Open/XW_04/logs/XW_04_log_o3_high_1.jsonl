{'completion_tokens': 28102, 'response': Response_structure(reasoning='Each operation relies on a shared helper (_resolve) that walks the directory tree from the root inode (#1) to return the inode of the requested path or raise the correct POSIX-style exceptions.  read() validates indices, gathers the file’s bytes from direct blocks and returns the requested slice decoded as UTF-8.  write() resolves the file, merges the new bytes into the old content, re-allocates blocks (freeing the old ones) and updates inode.size.  create() splits the path into parent/leaf, checks that the parent exists and is a directory, prevents duplicates, creates a fresh inode (file or dir) and inserts a directory entry.  delete() finds the target’s parent entry, refuses to remove non-empty directories, frees a file’s data blocks (or an empty directory table), deletes the inode and removes the entry.  All mutators return the same FileSystemImage instance; read() returns the data string.', config=ConfigFile(read="def read(fs_img: FileSystemImage, path: str, pos: int, length: int) -> str:\\n    '''Read up to `length` bytes from the file at `path` starting at offset `pos`.'''\\n    if pos < 0 or length < 0:\\n        raise ValueError('pos and length must be non-negative')\\n\\n    def _resolve(p: str):\\n        if p in ('', '/'):\\n            return fs_img.inodes[1]  # root inode assumed to be 1\\n        parts = [c for c in p.strip('/').split('/') if c]\\n        cur = fs_img.inodes[1]\\n        for comp in parts:\\n            if not cur.is_dir:\\n                raise NotADirectoryError(p)\\n            entry = next((e for e in fs_img.directories[cur.ino] if e.name == comp), None)\\n            if entry is None:\\n                raise FileNotFoundError(p)\\n            cur = fs_img.inodes[entry.inode]\\n        return cur\\n\\n    inode = _resolve(path)\\n    if inode.is_dir:\\n        raise IsADirectoryError(path)\\n\\n    data = b''.join(fs_img.data_blocks[idx] or b'' for idx in inode.direct_blocks)\\n    if pos >= len(data):\\n        return ''\\n    return data[pos:pos + length].decode('utf-8', errors='ignore')", write="def write(fs_img: FileSystemImage, path: str, pos: int, data: str) -> FileSystemImage:\\n    '''Write UTF-8 bytes of `data` into file `path` at offset `pos`.'''\\n    if pos < 0:\\n        raise ValueError('pos must be non-negative')\\n\\n    bdata = data.encode('utf-8')\\n\\n    def _resolve(p: str):\\n        if p in ('', '/'):\\n            return fs_img.inodes[1]\\n        parts = [c for c in p.strip('/').split('/') if c]\\n        cur = fs_img.inodes[1]\\n        for comp in parts:\\n            if not cur.is_dir:\\n                raise NotADirectoryError(p)\\n            entry = next((e for e in fs_img.directories[cur.ino] if e.name == comp), None)\\n            if entry is None:\\n                raise FileNotFoundError(p)\\n            cur = fs_img.inodes[entry.inode]\\n        return cur\\n\\n    inode = _resolve(path)\\n    if inode.is_dir:\\n        raise IsADirectoryError(path)\\n\\n    old_data = b''.join(fs_img.data_blocks[idx] or b'' for idx in inode.direct_blocks)\\n    if pos > len(old_data):\\n        old_data += b'\\x00' * (pos - len(old_data))\\n    new_content = old_data[:pos] + bdata + old_data[pos + len(bdata):]\\n\\n    # Recycle previous blocks\\n    for idx in list(inode.direct_blocks):\\n        fs_img.free_block(idx)\\n    inode.direct_blocks.clear()\\n\\n    block_size = fs_img.superblock.block_size\\n    for start in range(0, len(new_content), block_size):\\n        blk = fs_img.allocate_block()\\n        fs_img.data_blocks[blk] = new_content[start:start + block_size]\\n        inode.direct_blocks.append(blk)\\n    inode.size = len(new_content)\\n    return fs_img", create="def create(fs_img: FileSystemImage, path: str, is_dir: bool = False) -> FileSystemImage:\\n    '''Create a new file or directory at `path`.'''\\n    path = path.rstrip('/')\\n    if path == '':\\n        raise FileExistsError('Cannot create root')\\n\\n    parent_path, name = (path.rsplit('/', 1) if '/' in path else ('/', path))\\n    if parent_path == '':\\n        parent_path = '/'\\n\\n    def _resolve(p: str):\\n        if p in ('', '/'):\\n            return fs_img.inodes[1]\\n        parts = [c for c in p.strip('/').split('/') if c]\\n        cur = fs_img.inodes[1]\\n        for comp in parts:\\n            if not cur.is_dir:\\n                raise NotADirectoryError(p)\\n            entry = next((e for e in fs_img.directories[cur.ino] if e.name == comp), None)\\n            if entry is None:\\n                raise FileNotFoundError(p)\\n            cur = fs_img.inodes[entry.inode]\\n        return cur\\n\\n    parent_inode = _resolve(parent_path)\\n    if not parent_inode.is_dir:\\n        raise NotADirectoryError(parent_path)\\n    if any(e.name == name for e in fs_img.directories[parent_inode.ino]):\\n        raise FileExistsError(path)\\n\\n    new_inode = fs_img.create_inode(is_dir)\\n    fs_img.add_dir_entry(parent_inode.ino, name, new_inode.ino)\\n    return fs_img", delete="def delete(fs_img: FileSystemImage, path: str) -> FileSystemImage:\\n    '''Delete the entry at `path` and return the mutated image.'''\\n    path = path.rstrip('/')\\n    if path in ('', '/'):\\n        raise PermissionError('Cannot delete root directory')\\n\\n    parent_path, name = (path.rsplit('/', 1) if '/' in path else ('/', path))\\n    if parent_path == '':\\n        parent_path = '/'\\n\\n    def _resolve(p: str):\\n        if p in ('', '/'):\\n            return fs_img.inodes[1]\\n        parts = [c for c in p.strip('/').split('/') if c]\\n        cur = fs_img.inodes[1]\\n        for comp in parts:\\n            if not cur.is_dir:\\n                raise NotADirectoryError(p)\\n            entry = next((e for e in fs_img.directories[cur.ino] if e.name == comp), None)\\n            if entry is None:\\n                raise FileNotFoundError(p)\\n            cur = fs_img.inodes[entry.inode]\\n        return cur\\n\\n    parent_inode = _resolve(parent_path)\\n    if not parent_inode.is_dir:\\n        raise NotADirectoryError(parent_path)\\n    entries = fs_img.directories[parent_inode.ino]\\n    dir_entry = next((e for e in entries if e.name == name), None)\\n    if dir_entry is None:\\n        raise FileNotFoundError(path)\\n\\n    target_inode = fs_img.inodes[dir_entry.inode]\\n    if target_inode.is_dir:\\n        if fs_img.directories.get(target_inode.ino):\\n            if fs_img.directories[target_inode.ino]:\\n                raise OSError('Directory not empty')\\n        fs_img.directories.pop(target_inode.ino, None)\\n    else:\\n        for idx in target_inode.direct_blocks:\\n            fs_img.free_block(idx)\\n\\n    fs_img.inodes.pop(target_inode.ino, None)\\n    entries.remove(dir_entry)\\n    return fs_img")), 'passed': True, 'evaluation_result': {'delete': True, 'delete_nested': True, 'delete_parent': True, 'fnf_error': True, 'not_directory_error': True, 'dir_not_empty_error': True}, 'score': 100}
