Attempt 1:
reasoning='1. Observation of the raw Degree0 tile shows a perfect checker-board sampling pattern: every other pixel along both x and y directions is zero, i.e. valid samples lie on (row + col) % 2 == 0.\n\n2. In such a Bayer-like undersampling situation the simplest linear (bi–linear) reconstruction for a missing pixel (a black square on the checker board) is the average of its four direct neighbours (top, bottom, left, right).  Diagonal neighbours are second–order in the interpolation and can be ignored for the most basic kernel.\n\n3.  Convolutionally, that linear estimator can be represented with a 3×3 kernel whose centre coefficient is 1 (so that already-known pixels remain unchanged when the mask is later normalised or when masked addition is performed) and whose horizontal/vertical neighbours carry the same weight.  A convenient normalised set of weights is 0.5 for each of the four neighbours; the diagonal positions are 0 because they are not used in a strict bilinear pass.\n\n4.  Therefore the resulting kernel is:\n\n   [ 0   0.5  0  ]\n   [ 0.5  1   0.5]\n   [ 0   0.5  0  ]\n\n5.  During implementation one usually multiplies the kernel with a binary validity mask (1 for known, 0 for unknown) and afterwards divides by the sum of the applied weights; this yields the exact linear interpolation while keeping the original sampled pixels intact.\n\n6.  When AoLP and DoLP frames are later computed (which involve arctan2 and sqrt operations on the four angle intensities), the bilinearly filled Degree0 will preserve the correct local averages and therefore minimise angular error and polarisation-degree bias, which is exactly what the evaluation metric will look for.' config=ConfigFile(Kernel=[[0.0, 0.5, 0.0], [0.5, 1.0, 0.5], [0.0, 0.5, 0.0]])
Attempt 2:
reasoning='Problem recap\nThe raw Degree-0 frame contains a perfect 2 × 2 checkerboard: real samples lie where (row+col) is even, all other locations are zero.  The task is to reconstruct the missing values with a *single convolutional kernel whose centre coefficient is fixed to 1*, afterwards the AoLP/DoLP metrics are computed from the four filled channels.\n\nWhy the previous kernel was weak\nThe 3×3 mask that only averaged the four direct (N, E, S, W) neighbours throws away the diagonal information that is available one pixel away in both directions.  In a regular lattice those four extra neighbours carry the same distance (√2) to the empty location as the axial ones carry distance 1, therefore ignoring them keeps 50 % of the relevant energy out of the estimator and results in the low PSNR that was reported.\n\nImproved linear estimator\nKeep the same compact 3×3 support (fast and separable) but employ *all eight* surrounding samples.  A simple distance–weighted scheme gives the axial neighbours twice as much impact as each diagonal one – this preserves bilinear characteristics while still profiting from the extra information.\n\n            distance 1   →  weight 0.50\n            distance √2  →  weight 0.25\n            centre (known) → 1.00 (as required)\n\nThe complete 3×3 convolution kernel is therefore\n\n    [0.25  0.50  0.25]\n    [0.50  1.00  0.50]\n    [0.25  0.50  0.25]\n\nHow it is applied\n1. Build a binary mask M where M=1 for the original non-zero pixels, 0 otherwise.\n2. Convolve Degree0 and M with the same kernel K.\n3. Reconstructed image = (K * Degree0) / (K * M)   (division is point-wise and only on the previously empty positions; keep the original values where M=1).\n\nBecause both numerator and denominator are filtered with *identical* weights, the absolute scale of the kernel is irrelevant – only the relative ratios matter.  The proposed mask uses more information than the earlier attempt while obeying the “centre = 1” constraint, which leads to noticeably higher PSNR/SSIM for Degree-0 and consequently cleaner AoLP/DoLP maps.' config=ConfigFile(Kernel=[[0.25, 0.5, 0.25], [0.5, 1.0, 0.5], [0.25, 0.5, 0.25]])
