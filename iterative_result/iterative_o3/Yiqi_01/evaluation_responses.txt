Attempt 1:
reasoning='Goal: produce execution plan for MatMul (m=128,k=5120,n=15360) on Graphcore IPU Mk2 with 1472 × 624 KB cores, using T10 abstraction.\n\nKey constraints\n• Per-core data < 624 KB.\n• ≤1472 cores.\n• Sub-matmul sizes preferably multiples of the 16 × 16 systolic array.\n• Temporal-factor alignment rules (product must divide #sharing-cores, mutual factors).\n\nStep-1  Choose spatial partition F_op = [F_m,F_k,F_n]\n– Partition n heavily (largest dim) to spread B & C.\n– Also split k moderately to shrink A & B per core.\n– Keep m un-partitioned (small already) to save cores.\n\nPick F_k = 10  ⇒  K’ = 512  (5120/10)\nPick F_n = 96 ⇒  N’ = 160  (15360/96)\nCores used = 1×10×96 = 960  (≤1472), leaves headroom for other ops.\nAll sub-dims (M’=128, K’=512, N’=160) are multiples of 16 so no padding.\n\nStep-2  Memory check per core (FP16 =2 bytes)\nA’ 128×512   = 65 536 el =   128 KB\nB’ 512×160   = 81 920 el =   160 KB\nC’ 128×160   = 20 480 el =    40 KB\nTotal data                    ≈ 328 KB  < 624 KB ok.\nA is missing axis n in F_op, hence its 10 spatial sub-tensors are shared among 96 cores each. We simply replicate them (no shifting), so we set all temporal factors to 1; replication cost fits memory budget (128 KB per core already counted). B and C include all the axes they need, so they also take f_t=1.\n\nStep-3  Temporal factors (all 1) satisfy alignment rule (any two are factors of each other).\n\nOutcome\n• Fast (large 128×160×512 compute per core, full utilisation of 16×16 array)\n• 960 cores, < 624 KB/core, no inter-core shifts required ⇒ minimal communication.\n\nTherefore produce config:' config=ConfigFile(F_op=[1, 10, 96], f_t_A_m=1, f_t_A_k=1, f_t_B_k=1, f_t_B_n=1, f_t_C_m=1, f_t_C_n=1)
